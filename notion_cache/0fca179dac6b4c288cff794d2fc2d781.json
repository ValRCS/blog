{
  "ID": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
  "Page": {
    "alive": true,
    "content": [
      "2a7c651b-8163-4656-8f99-728a8674c4ae",
      "0365d9be-1834-43e0-92c5-bddd6520d407",
      "57c4126d-b811-4a4f-9f6e-79741938aaf1",
      "2a8fe71f-0a37-406c-a155-212cebf35fbd",
      "b99f19ff-a5eb-4016-a93f-22895e44ceb2",
      "31d29079-15eb-4c71-868b-7c7686bf1606",
      "253a866d-708e-4861-83b5-b4f2af575ec0",
      "d25eff9a-8ec6-4ff0-af62-b3773b80eda2",
      "7767b6ef-410c-4e54-af35-8fe95003ddc2",
      "9e672e36-1ff8-43a1-b32c-574342157d5a",
      "1c4bdb29-2bd6-4a9b-a9f4-c593a6962b59",
      "397213c0-27f5-4aa2-b7be-91ae59406705",
      "3db07116-434c-409e-a226-96d20695c3da",
      "dce236d7-99ce-4eb4-bc92-4fad7e828f84",
      "eb6fc333-23b7-4905-bb98-ed7f075bbe3b",
      "6cce83b7-41e9-403f-ac9a-72c43e51a7af",
      "975165cc-545c-4dbf-827b-48f2b43e59a1",
      "a968d966-3931-471f-bec4-cb69086b7cc4",
      "8da760d2-e4ae-46c2-8179-461e0e559f6e",
      "14d752d3-f665-46c7-92cc-fe26cd989f5d",
      "bd5efa63-6b3a-4aaa-9f96-de53b047cdcb",
      "15528e76-928f-4644-a637-2eab07eebd90",
      "838b4b98-f452-4d82-890c-3aceacf5b840",
      "cda3803c-32d1-4376-bc72-ee8670c28f85",
      "aea665e6-472d-4c69-a894-5f9beeecfe69",
      "ab3d653f-c514-4684-92ae-69822fd07e12",
      "f974dec3-a8cd-4260-a6c8-521b58b36c68",
      "5c7c6d2f-2f81-4df5-8ac1-42196c5d2e2e",
      "8f57f678-72f9-41fc-8f15-1fee58141bd8",
      "767c583c-5f7a-4788-976d-d9e0dded00b1",
      "37cd6c22-7875-493c-9300-e4cbc117b6ec",
      "fb4d8126-ab19-4411-9c2e-8925050a610e",
      "9725ccc7-acbe-45c6-9882-afead65135e2",
      "7b7300fc-cc85-429e-a6fa-4335a3c42d2c",
      "37425840-3c95-4310-bb86-541dddcec88a",
      "2a28bd1f-4cee-487f-9821-a88f2b196cc3",
      "f6cabb8d-e406-4b70-8021-db6395942db8",
      "94d88750-45de-40d4-9fb2-f7659bee4951",
      "81cae7d8-9fb4-457e-bf13-f3f0c95d8901",
      "a07ed5ff-e9b6-4a2d-a32f-6b2c441c88b2",
      "8310de26-9916-4899-a02f-9229f02e47a1",
      "8730548a-9a83-4476-8599-1ac7d2d61886",
      "559b88e8-0e45-46d4-a46d-d9b83b0737ee",
      "8f4f2967-7037-490b-b739-e35ba4adfb61",
      "4fe77032-792d-4dc7-b3fc-506c1687465c",
      "c26852ca-5658-4f9a-a414-8cc129414794",
      "3422445e-7b32-4906-ba7a-414ffc09ddc2",
      "8a750732-8764-4bba-ac84-78f605b909ac",
      "002f0edc-e316-4722-a104-84c2a21e2d25",
      "0aeb092f-21a6-4167-84a4-c861a723f734",
      "6cc718e8-27f8-4baa-bf79-71ae746df9ea",
      "b1b87bb3-8bd5-42b6-89c6-cdef6d822e4e",
      "2c4b59dc-6e5f-4ee9-834d-cb23807d7b38",
      "5358f950-4ea2-4b35-b41d-45afc88e14ce",
      "f01421ea-50bb-4fe3-9c5d-712b76cfabd9",
      "a307eae6-fd0b-42c3-950e-49dc2ed47df7",
      "b5c61c57-a3f3-41b7-b61d-265b91ab2609",
      "e3223ca4-e049-41b3-b1d9-ca904c71fb4d",
      "875ebbf9-0d76-4f5e-8703-6603df878c18",
      "a03b662f-9248-4ec3-abf4-7037e2634079",
      "b0ddfc3f-1ee9-48a7-bfd3-1984b52528c3",
      "244d3a6a-594d-4dcf-bc25-852b4d63f408",
      "4f733808-840b-43ad-8451-df0dee012c95",
      "4da12a54-38a6-48db-99db-42dff6d73ec0",
      "b6633d65-8e57-4f5e-9fab-f292d942ba0d",
      "871b1b8b-1c37-41ff-af2f-e99aa8348693",
      "9d0df0ea-fd97-44be-8cde-f7d584925a2e",
      "80e61c4d-1a34-412a-9e70-530154235705",
      "961ddacb-b8dd-43fe-88cc-e794a5fd324c",
      "047bf3ad-855b-465e-91ef-acb6b094f156",
      "11d3c228-bc01-4757-87b2-e8967b26b2a3",
      "26a9e234-53d1-4140-be0a-bcfd9baae782",
      "190b7c4d-8228-4602-835a-dce7842b23fd",
      "df800f4d-e67b-41bd-984a-b8de6c6bbdb8",
      "b8f46bd3-4e20-4723-99b6-0c53db94c896",
      "ffa69c8b-f12d-4002-835e-3eac4fe5de7a",
      "763d2cfc-196a-492a-8094-c13f47b7f846",
      "180a5fa3-6560-40ce-ae62-569d751dc529",
      "768a3e9e-805a-4ff6-bfed-3ccb8fc3b7ee",
      "b9e8bc84-5296-4bc1-aa4f-f9f1bd84bb6a",
      "09ad2a20-61f2-4972-90c5-f4e1b81622bd",
      "e05c0c05-ecb4-489d-9227-a0e26680bf44",
      "aae320e6-d0a1-4e39-953c-ef9ecb4354f2",
      "fc01b9b6-c0c1-4375-8979-06d7b97922af",
      "e668209b-e298-40cb-9768-a2f0b7708666",
      "fabc50a6-7f2e-46f4-a131-41aafe9b7489",
      "061b6ac3-7c0c-421c-8d22-ffd1421a2192",
      "6604d525-8f4a-4eda-a0fb-16f98bfdb948",
      "f11db5aa-ce54-4aee-89bd-e69401a2883c",
      "8ea01b16-77cb-40a5-9b6e-f20d28252681",
      "911413b2-ebbd-46e3-a75a-b9a1c0561370",
      "e025a574-bade-4e9d-a8d0-287ffccb0017",
      "a475f23c-5ce0-4f59-bae9-bc69537d19a7",
      "cd8a7336-5bcf-4544-9115-312b05f19982",
      "abdbe564-8ed9-4069-a75c-865c98f2b3ff",
      "0c14091c-a6ed-4540-8e84-ff27b8844a2e",
      "c0bb88f8-acd1-4803-9b69-2b88ab90e0e7",
      "9fcfc93e-1dae-4f07-8263-0c62b7b9c74c",
      "11b06fb6-9642-4e68-ada1-fa0360e53d95",
      "485e3a97-f021-4b9b-bd1b-a3c5a4b59f8e",
      "5c3dc8e1-881c-4905-8213-6e93bc52f139",
      "1af25c0c-a60f-4982-9bf2-1b6377ea7e8f",
      "303e5758-e30b-4c91-a5f5-0f5b9c0ee7b9",
      "029f189b-bf32-4ce7-82a4-ed9ac1503dec",
      "b9a5164c-f689-4de1-bc3a-c31168cef26e",
      "3b4ca90c-eceb-4f56-afe5-e5d7b094128b",
      "ff0a358b-0f5f-4a8d-84cc-6d5133ae1391",
      "cbdec4d0-bcf5-4194-8e60-db3cc7b6db26",
      "0ffc42d9-811b-446b-b5ea-82e0b45a6793",
      "3beb8b30-dd1e-4e52-866c-d5454a26de61",
      "0b499391-2bd2-4f9a-a2cd-342c6a006b4b",
      "8332a297-3fb6-4e65-997f-eb475ee5c5aa",
      "48df2dc0-5c18-4af2-9d63-fa57e985eb6d",
      "78d7062b-6676-4c4c-b7af-1e9e0659204a",
      "bab5ffc8-28d5-4e1b-8edf-58056b730a7e",
      "00375ce4-bfd6-4e87-a615-ac825b05681e",
      "a8bcdcaf-fd7a-4e48-b8e3-4fc2dc1cda2a",
      "658e4471-475d-4733-bf32-c40121fb036d",
      "35cb884e-b04b-473e-a777-36739d8937cf",
      "e275402e-12dc-4530-8843-c698dbdccaa6",
      "bc7b7d16-73e6-4f1c-b546-a31dfb96de8e",
      "07929c62-2a4f-46d8-b1f5-d0873f77251d",
      "9f73fa23-7096-4c21-a483-84303dc57b9b",
      "1beaf7a6-f7f3-4878-a5fc-5e0fd69ee7bc",
      "a5d8aea0-fc47-4b1a-bf06-3cbf9c9fce76",
      "5514cf2c-3efb-41a8-8e76-2d868d9c9629",
      "1a854632-e9bf-4017-b075-d17c835c4557",
      "9f9b7a58-6d15-4d05-b8d1-5c8c2a822765",
      "ebcd215b-2d00-4487-b124-17add1e085b9",
      "766d4fcf-3481-476e-9f11-981365cbc282",
      "eb426ca0-e7a8-457c-b655-6dc9bdda64e1",
      "f7be3258-0896-4962-b936-8bd65e1ae044",
      "c84e3f15-9a6b-495c-ba1d-2c4e1038ac86",
      "9c55466e-2488-425a-8233-c28e5c3ceda5",
      "b8a34aa7-789e-461c-93f2-f7e789706a9d",
      "670db396-dacf-4493-83de-7ef2b9272272",
      "1e9591ce-c73e-4d05-83f6-d240b8e6bcae",
      "ca8945e4-2a43-4a48-845a-e6331bbc530a",
      "23882655-d9fe-43be-b2a6-c3859a840533"
    ],
    "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "created_time": 1530072938453,
    "format": {
      "page_full_width": true,
      "page_small_text": true
    },
    "id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
    "ignore_block_count": true,
    "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
    "last_edited_time": 1530073038935,
    "parent_id": "65db085c-d90f-45d2-a271-8f19a7566e1b",
    "parent_table": "block",
    "permissions": [
      {
        "role": "editor",
        "type": "user_permission",
        "user_id": "bb760e2d-d679-4b64-b2a9-03005b21870a"
      }
    ],
    "properties": {
      "title": [
        [
          "PE file format description"
        ]
      ]
    },
    "type": "page",
    "version": 76,
    "content_resolved": [
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938393,
        "id": "2a7c651b-8163-4656-8f99-728a8674c4ae",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530073002130,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The Portable Executable File Format",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "header",
        "version": 7,
        "inline_content": [
          {
            "Text": "The Portable Executable File Format",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938403,
        "id": "0365d9be-1834-43e0-92c5-bddd6520d407",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530073001024,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Introduction"
            ]
          ]
        },
        "type": "sub_header",
        "version": 6,
        "inline_content": [
          {
            "Text": "Introduction"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938403,
        "id": "57c4126d-b811-4a4f-9f6e-79741938aaf1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938403,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The recent addition of the Microsoft® Windows NT™ operating system to the family of Windows™ operating systems brought many changes to the development environment and more than a few changes to applications themselves. One of the more significant changes is the introduction of the Portable Executable (PE) file format. The new PE file format draws primarily from the COFF (Common Object File Format) specification that is common to UNIX® operating systems. Yet, to remain compatible with previous versions of the MS-DOS® and Windows operating systems, the PE file format also retains the old familiar MZ header from MS-DOS. This article discusses each of the components of the file as they occur when you traverse the file’s contents, starting at the top and working your way down through the file. Much of the definition of individual file components comes from the file WINNT.H, a file included in the Microsoft Win32™ Software Development Kit (SDK) for Windows NT. In it you will find structure type definitions for each of the file headers and data directories used to represent various components in the file. In other places in the file, WINNT.H lacks sufficient definition of the file structure. The PE file format for Windows NT introduces a completely new structure to developers familiar with the Windows and MS-DOS environments. Yet developers familiar with the UNIX environment will find that the PE file format is similar to, if not based on, the COFF specification. The entire format consists of an MS-DOS MZ header, followed by a real-mode stub program, the PE file signature, the PE file header, the PE optional header, all of the section headers, and finally, all of the section bodies. The optional header ends with an array of data directory entries that are relative virtual addresses to data directories contained within section bodies. Each data directory indicates how a specific section body’s data is structured. The PE file format has eleven predefined sections, as is common to applications for Windows NT, but each application can define its own unique sections for code and data. The .debug predefined section also has the capability of being stripped from the file into a separate debug file. If so, a special debug header is used to parse the debug file, and a flag is specified in the PE file header to indicate that the debug data has been stripped."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The recent addition of the Microsoft® Windows NT™ operating system to the family of Windows™ operating systems brought many changes to the development environment and more than a few changes to applications themselves. One of the more significant changes is the introduction of the Portable Executable (PE) file format. The new PE file format draws primarily from the COFF (Common Object File Format) specification that is common to UNIX® operating systems. Yet, to remain compatible with previous versions of the MS-DOS® and Windows operating systems, the PE file format also retains the old familiar MZ header from MS-DOS. This article discusses each of the components of the file as they occur when you traverse the file’s contents, starting at the top and working your way down through the file. Much of the definition of individual file components comes from the file WINNT.H, a file included in the Microsoft Win32™ Software Development Kit (SDK) for Windows NT. In it you will find structure type definitions for each of the file headers and data directories used to represent various components in the file. In other places in the file, WINNT.H lacks sufficient definition of the file structure. The PE file format for Windows NT introduces a completely new structure to developers familiar with the Windows and MS-DOS environments. Yet developers familiar with the UNIX environment will find that the PE file format is similar to, if not based on, the COFF specification. The entire format consists of an MS-DOS MZ header, followed by a real-mode stub program, the PE file signature, the PE file header, the PE optional header, all of the section headers, and finally, all of the section bodies. The optional header ends with an array of data directory entries that are relative virtual addresses to data directories contained within section bodies. Each data directory indicates how a specific section body’s data is structured. The PE file format has eleven predefined sections, as is common to applications for Windows NT, but each application can define its own unique sections for code and data. The .debug predefined section also has the capability of being stripped from the file into a separate debug file. If so, a special debug header is used to parse the debug file, and a flag is specified in the PE file header to indicate that the debug data has been stripped."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938403,
        "id": "2a8fe71f-0a37-406c-a155-212cebf35fbd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938403,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Structure of PE Files"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Structure of PE Files"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938403,
        "id": "b99f19ff-a5eb-4016-a93f-22895e44ceb2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938403,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The PE file format is organized as a linear stream of data. It begins with an MS-DOS header, a real-mode program stub, and a PE file signature. Immediately following is a PE file header and optional header. Beyond that, all the section headers appear, followed by all of the section bodies. Closing out the file are a few other regions of miscellaneous information, including relocation information, symbol table information, line number information, and string table data. All of this is more easily absorbed by looking at it graphically, as shown in Figure 1. "
            ],
            [
              "Figure 1. Structure of a Portable Executable file image",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " Starting with the MS-DOS file header structure, each of the components in the PE file format is discussed below in the order in which it occurs in the file."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The PE file format is organized as a linear stream of data. It begins with an MS-DOS header, a real-mode program stub, and a PE file signature. Immediately following is a PE file header and optional header. Beyond that, all the section headers appear, followed by all of the section bodies. Closing out the file are a few other regions of miscellaneous information, including relocation information, symbol table information, line number information, and string table data. All of this is more easily absorbed by looking at it graphically, as shown in Figure 1. "
          },
          {
            "Text": "Figure 1. Structure of a Portable Executable file image",
            "AttrFlags": 1
          },
          {
            "Text": " Starting with the MS-DOS file header structure, each of the components in the PE file format is discussed below in the order in which it occurs in the file."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938403,
        "id": "31d29079-15eb-4c71-868b-7c7686bf1606",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938403,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MS-DOS/Real-Mode Header"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "MS-DOS/Real-Mode Header"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938404,
        "id": "253a866d-708e-4861-83b5-b4f2af575ec0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938404,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As mentioned above, the first component in the PE file format is the MS-DOS header. The MS-DOS header is not new for the PE file format. It is the same MS-DOS header that has been around since version 2 of the MS-DOS operating system. The main reason for keeping the same structure intact at the beginning of the PE file format is so that, when you attempt to load a file created under Windows version 3.1 or earlier, or MS DOS version 2.0 or later, the operating system can read the file and understand that it is not compatible. In other words, when you attempt to run a Windows NT executable on MS-DOS version 6.0, you get this message: “This program cannot be run in DOS mode.” If the MS-DOS header was not included as the first part of the PE file format, the operating system would simply fail the attempt to load the file and offer something completely useless, such as: “The name specified is not recognized as an internal or external command, operable program or batch file.” The MS-DOS header occupies the first 64 bytes of the PE file. A structure representing its content is described below: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As mentioned above, the first component in the PE file format is the MS-DOS header. The MS-DOS header is not new for the PE file format. It is the same MS-DOS header that has been around since version 2 of the MS-DOS operating system. The main reason for keeping the same structure intact at the beginning of the PE file format is so that, when you attempt to load a file created under Windows version 3.1 or earlier, or MS DOS version 2.0 or later, the operating system can read the file and understand that it is not compatible. In other words, when you attempt to run a Windows NT executable on MS-DOS version 6.0, you get this message: “This program cannot be run in DOS mode.” If the MS-DOS header was not included as the first part of the PE file format, the operating system would simply fail the attempt to load the file and offer something completely useless, such as: “The name specified is not recognized as an internal or external command, operable program or batch file.” The MS-DOS header occupies the first 64 bytes of the PE file. A structure representing its content is described below: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938404,
        "id": "d25eff9a-8ec6-4ff0-af62-b3773b80eda2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938404,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_DOS_HEADER {  // DOS .EXE header\n    USHORT e_magic;         // Magic number\n    USHORT e_cblp;          // Bytes on last page of file\n    USHORT e_cp;            // Pages in file\n    USHORT e_crlc;          // Relocations\n    USHORT e_cparhdr;       // Size of header in paragraphs\n    USHORT e_minalloc;      // Minimum extra paragraphs needed\n    USHORT e_maxalloc;      // Maximum extra paragraphs needed\n    USHORT e_ss;            // Initial (relative) SS value\n    USHORT e_sp;            // Initial SP value\n    USHORT e_csum;          // Checksum\n    USHORT e_ip;            // Initial IP value\n    USHORT e_cs;            // Initial (relative) CS value\n    USHORT e_lfarlc;        // File address of relocation table\n    USHORT e_ovno;          // Overlay number\n    USHORT e_res[4];        // Reserved words\n    USHORT e_oemid;         // OEM identifier (for e_oeminfo)\n    USHORT e_oeminfo;       // OEM information; e_oemid specific\n    USHORT e_res2[10];      // Reserved words\n    LONG   e_lfanew;        // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_DOS_HEADER {  // DOS .EXE header\n    USHORT e_magic;         // Magic number\n    USHORT e_cblp;          // Bytes on last page of file\n    USHORT e_cp;            // Pages in file\n    USHORT e_crlc;          // Relocations\n    USHORT e_cparhdr;       // Size of header in paragraphs\n    USHORT e_minalloc;      // Minimum extra paragraphs needed\n    USHORT e_maxalloc;      // Maximum extra paragraphs needed\n    USHORT e_ss;            // Initial (relative) SS value\n    USHORT e_sp;            // Initial SP value\n    USHORT e_csum;          // Checksum\n    USHORT e_ip;            // Initial IP value\n    USHORT e_cs;            // Initial (relative) CS value\n    USHORT e_lfarlc;        // File address of relocation table\n    USHORT e_ovno;          // Overlay number\n    USHORT e_res[4];        // Reserved words\n    USHORT e_oemid;         // OEM identifier (for e_oeminfo)\n    USHORT e_oeminfo;       // OEM information; e_oemid specific\n    USHORT e_res2[10];      // Reserved words\n    LONG   e_lfanew;        // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938404,
        "id": "7767b6ef-410c-4e54-af35-8fe95003ddc2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938404,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The first field, "
            ],
            [
              "e_magic",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", is the so-called magic number. This field is used to identify an MS-DOS-compatible file type. All MS-DOS-compatible executable files set this value to 0x54AD, which represents the ASCII characters "
            ],
            [
              "MZ",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". MS-DOS headers are sometimes referred to as MZ headers for this reason. Many other fields are important to MS-DOS operating systems, but for Windows NT, there is really one more important field in this structure. The final field, "
            ],
            [
              "e_lfanew",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", is a 4-byte offset into the file where the PE file header is located. It is necessary to use this offset to locate the PE header in the file. For PE files in Windows NT, the PE file header occurs soon after the MS-DOS header with only the real-mode stub program between them."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The first field, "
          },
          {
            "Text": "e_magic",
            "AttrFlags": 1
          },
          {
            "Text": ", is the so-called magic number. This field is used to identify an MS-DOS-compatible file type. All MS-DOS-compatible executable files set this value to 0x54AD, which represents the ASCII characters "
          },
          {
            "Text": "MZ",
            "AttrFlags": 4
          },
          {
            "Text": ". MS-DOS headers are sometimes referred to as MZ headers for this reason. Many other fields are important to MS-DOS operating systems, but for Windows NT, there is really one more important field in this structure. The final field, "
          },
          {
            "Text": "e_lfanew",
            "AttrFlags": 1
          },
          {
            "Text": ", is a 4-byte offset into the file where the PE file header is located. It is necessary to use this offset to locate the PE header in the file. For PE files in Windows NT, the PE file header occurs soon after the MS-DOS header with only the real-mode stub program between them."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938405,
        "id": "9e672e36-1ff8-43a1-b32c-574342157d5a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938405,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Real-Mode Stub Program"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Real-Mode Stub Program"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938406,
        "id": "1c4bdb29-2bd6-4a9b-a9f4-c593a6962b59",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938406,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The real-mode stub program is an actual program run by MS-DOS when the executable is loaded. For an actual MS-DOS executable image file, the application begins executing here. For successive operating systems, including Windows, OS/2®, and Windows NT, an MS-DOS stub program is placed here that runs instead of the actual application. The programs typically do no more than output a line of text, such as: “This program requires Microsoft Windows v3.1 or greater.” Of course, whoever creates the application is able to place any stub they like here, meaning you may often see such things as: “You can’t run a Windows NT application on OS/2, it’s simply not possible.” When building an application for Windows version 3.1, the linker links a default stub program called WINSTUB.EXE into your executable. You can override the default linker behavior by substituting your own valid MS-DOS-based program in place of WINSTUB and indicating this to the linker with the "
            ],
            [
              "STUB",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " module definition statement. Applications developed for Windows NT can do the same thing by using the "
            ],
            [
              "-STUB: linker",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " option when linking the executable file."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The real-mode stub program is an actual program run by MS-DOS when the executable is loaded. For an actual MS-DOS executable image file, the application begins executing here. For successive operating systems, including Windows, OS/2®, and Windows NT, an MS-DOS stub program is placed here that runs instead of the actual application. The programs typically do no more than output a line of text, such as: “This program requires Microsoft Windows v3.1 or greater.” Of course, whoever creates the application is able to place any stub they like here, meaning you may often see such things as: “You can’t run a Windows NT application on OS/2, it’s simply not possible.” When building an application for Windows version 3.1, the linker links a default stub program called WINSTUB.EXE into your executable. You can override the default linker behavior by substituting your own valid MS-DOS-based program in place of WINSTUB and indicating this to the linker with the "
          },
          {
            "Text": "STUB",
            "AttrFlags": 1
          },
          {
            "Text": " module definition statement. Applications developed for Windows NT can do the same thing by using the "
          },
          {
            "Text": "-STUB: linker",
            "AttrFlags": 1
          },
          {
            "Text": " option when linking the executable file."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938406,
        "id": "397213c0-27f5-4aa2-b7be-91ae59406705",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938406,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "PE File Header and Signature"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "PE File Header and Signature"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938406,
        "id": "3db07116-434c-409e-a226-96d20695c3da",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938406,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The PE file header is lo cated by indexing the "
            ],
            [
              "e_lfanew",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " field of the MS-DOS header. The "
            ],
            [
              "e_lfanew",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " field simply gives the offset in the file, so add the file’s memory-mapped base address to determine the actual memory-mapped address"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The PE file header is lo cated by indexing the "
          },
          {
            "Text": "e_lfanew",
            "AttrFlags": 1
          },
          {
            "Text": " field of the MS-DOS header. The "
          },
          {
            "Text": "e_lfanew",
            "AttrFlags": 1
          },
          {
            "Text": " field simply gives the offset in the file, so add the file’s memory-mapped base address to determine the actual memory-mapped address"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938406,
        "id": "dce236d7-99ce-4eb4-bc92-4fad7e828f84",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938406,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a +    \\\n                        ((PIMAGE_DOS_HEADER)a)-\u003ee_lfanew))"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a +    \\\n                        ((PIMAGE_DOS_HEADER)a)-\u003ee_lfanew))",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938407,
        "id": "eb6fc333-23b7-4905-bb98-ed7f075bbe3b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938407,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "When manipulating PE file information, I found that there were several locations in the file that I needed to refer to often. Since these locations are merely offsets into the file, it is easier to implement these locations as macros because they provide much better performance than functions do. Notice that instead of retrieving the offset of the PE file header, this macro retrieves the location of the PE file signature. Starting with Windows and OS/2 executables, .EXE files were given file signatures to specify the intended target operating system. For the PE file format in Windows NT, this signature occurs immediately before the PE file header structure. In versions of Windows and OS/2, the signature is the first word of the file header. Also, for the PE file format, Windows NT uses a DWORD for the signature. The macro presented above returns the offset of where the file signature appears, regardless of which type of executable file it is. So depending on whether it’s a Windows NT file signature or not, the file header exists either after the signature DWORD or at the signature WORD."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "When manipulating PE file information, I found that there were several locations in the file that I needed to refer to often. Since these locations are merely offsets into the file, it is easier to implement these locations as macros because they provide much better performance than functions do. Notice that instead of retrieving the offset of the PE file header, this macro retrieves the location of the PE file signature. Starting with Windows and OS/2 executables, .EXE files were given file signatures to specify the intended target operating system. For the PE file format in Windows NT, this signature occurs immediately before the PE file header structure. In versions of Windows and OS/2, the signature is the first word of the file header. Also, for the PE file format, Windows NT uses a DWORD for the signature. The macro presented above returns the offset of where the file signature appears, regardless of which type of executable file it is. So depending on whether it’s a Windows NT file signature or not, the file header exists either after the signature DWORD or at the signature WORD."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938407,
        "id": "6cce83b7-41e9-403f-ac9a-72c43e51a7af",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938407,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "DWORD  WINAPI ImageFileType (\n    LPVOID    lpFile)\n{\n    /* DOS file signature comes first. */\n    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)\n        {\n        /* Determine location of PE File header from\n           DOS header. */\n        if (LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) ==\n                                IMAGE_OS2_SIGNATURE ||\n            LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) ==\n                             IMAGE_OS2_SIGNATURE_LE)\n            return (DWORD)LOWORD(*(DWORD *)NTSIGNATURE (lpFile));\n\n        else if (*(DWORD *)NTSIGNATURE (lpFile) ==\n                            IMAGE_NT_SIGNATURE)\n            return IMAGE_NT_SIGNATURE;\n\n        else\n            return IMAGE_DOS_SIGNATURE;\n        }\n\n    else\n        /* unknown file type */\n        return 0;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "DWORD  WINAPI ImageFileType (\n    LPVOID    lpFile)\n{\n    /* DOS file signature comes first. */\n    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)\n        {\n        /* Determine location of PE File header from\n           DOS header. */\n        if (LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) ==\n                                IMAGE_OS2_SIGNATURE ||\n            LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) ==\n                             IMAGE_OS2_SIGNATURE_LE)\n            return (DWORD)LOWORD(*(DWORD *)NTSIGNATURE (lpFile));\n\n        else if (*(DWORD *)NTSIGNATURE (lpFile) ==\n                            IMAGE_NT_SIGNATURE)\n            return IMAGE_NT_SIGNATURE;\n\n        else\n            return IMAGE_DOS_SIGNATURE;\n        }\n\n    else\n        /* unknown file type */\n        return 0;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938407,
        "id": "975165cc-545c-4dbf-827b-48f2b43e59a1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938407,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The code listed above quickly shows how useful the "
            ],
            [
              "NTSIGNATURE",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " macro becomes. The macro makes it easy to compare the different file types and return the appropriate one for a given type of file. The four different file types defined in WINNT.H are: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The code listed above quickly shows how useful the "
          },
          {
            "Text": "NTSIGNATURE",
            "AttrFlags": 1
          },
          {
            "Text": " macro becomes. The macro makes it easy to compare the different file types and return the appropriate one for a given type of file. The four different file types defined in WINNT.H are: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938407,
        "id": "a968d966-3931-471f-bec4-cb69086b7cc4",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938407,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ\n#define IMAGE_OS2_SIGNATURE             0x454E      // NE\n#define IMAGE_OS2_SIGNATURE_LE          0x454C      // LE\n#define IMAGE_NT_SIGNATURE              0x00004550  // PE00"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ\n#define IMAGE_OS2_SIGNATURE             0x454E      // NE\n#define IMAGE_OS2_SIGNATURE_LE          0x454C      // LE\n#define IMAGE_NT_SIGNATURE              0x00004550  // PE00",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938407,
        "id": "8da760d2-e4ae-46c2-8179-461e0e559f6e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938407,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "At first it seems curious that Windows executable file types do not appear on this list. But then, after a little investigation, the reason becomes clear: There really is no difference between Windows executables and OS/2 executables other than the operating system version specification. Both operating systems share the same executable file structure. Turning our attention back to the Windows NT PE file format, we find that once we have the location of the file signature, the PE file follows four bytes later. The next macro identifies the PE file header:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "At first it seems curious that Windows executable file types do not appear on this list. But then, after a little investigation, the reason becomes clear: There really is no difference between Windows executables and OS/2 executables other than the operating system version specification. Both operating systems share the same executable file structure. Turning our attention back to the Windows NT PE file format, we find that once we have the location of the file signature, the PE file follows four bytes later. The next macro identifies the PE file header:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938407,
        "id": "14d752d3-f665-46c7-92cc-fe26cd989f5d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938407,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a +  \\\n    ((PIMAGE_DOS_HEADER)a)-\u003ee_lfanew + SIZE_OF_NT_SIGNATURE))"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a +  \\\n    ((PIMAGE_DOS_HEADER)a)-\u003ee_lfanew + SIZE_OF_NT_SIGNATURE))",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938409,
        "id": "bd5efa63-6b3a-4aaa-9f96-de53b047cdcb",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938409,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The only difference between this and the previous macro is that this one adds in the constant SIZE_OF_NT_SIGNATURE. Sad to say, this constant is not defined in WINNT.H. Now that we know the location of the PE file header, we can examine the data in the header simply by assigning this location to a structure, as in the following example:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The only difference between this and the previous macro is that this one adds in the constant SIZE_OF_NT_SIGNATURE. Sad to say, this constant is not defined in WINNT.H. Now that we know the location of the PE file header, we can examine the data in the header simply by assigning this location to a structure, as in the following example:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938409,
        "id": "15528e76-928f-4644-a637-2eab07eebd90",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938409,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "PIMAGE_FILE_HEADER   pfh;\n\npfh = (PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile);"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "PIMAGE_FILE_HEADER   pfh;\n\npfh = (PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile);",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938409,
        "id": "838b4b98-f452-4d82-890c-3aceacf5b840",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938409,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "In this example, "
            ],
            [
              "lpFile",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " represents a pointer to the base of the memory-mapped executable file, and therein lies the convenience of memory-mapped files. No file I/O needs to be performed; simply dereference the pointer "
            ],
            [
              "pfh",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " to access information in the file. The PE file header structure is defined as: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "In this example, "
          },
          {
            "Text": "lpFile",
            "AttrFlags": 4
          },
          {
            "Text": " represents a pointer to the base of the memory-mapped executable file, and therein lies the convenience of memory-mapped files. No file I/O needs to be performed; simply dereference the pointer "
          },
          {
            "Text": "pfh",
            "AttrFlags": 4
          },
          {
            "Text": " to access information in the file. The PE file header structure is defined as: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938409,
        "id": "cda3803c-32d1-4376-bc72-ee8670c28f85",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938409,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_FILE_HEADER {\n    USHORT  Machine;\n    USHORT  NumberOfSections;\n    ULONG   TimeDateStamp;\n    ULONG   PointerToSymbolTable;\n    ULONG   NumberOfSymbols;\n    USHORT  SizeOfOptionalHeader;\n    USHORT  Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n#define IMAGE_SIZEOF_FILE_HEADER             20"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_FILE_HEADER {\n    USHORT  Machine;\n    USHORT  NumberOfSections;\n    ULONG   TimeDateStamp;\n    ULONG   PointerToSymbolTable;\n    ULONG   NumberOfSymbols;\n    USHORT  SizeOfOptionalHeader;\n    USHORT  Characteristics;\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n#define IMAGE_SIZEOF_FILE_HEADER             20",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938410,
        "id": "aea665e6-472d-4c69-a894-5f9beeecfe69",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938410,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Notice that the size of the file header structure is conveniently defined in the include file… The information in the PE file is basically high-level information that is used by the system or applications to determine how to treat the file. The first field is used to indicate what type of machine the executable was built for, such as the DEC® Alpha, MIPS R4000, Intel® x86, or some other processor. The system uses this information to quickly determine how to treat the file before going any further into the rest of the file data. The "
            ],
            [
              "Characteristics",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field identifies specific characteristics about the file. For example, consider how separate debug files are managed for an executable. It is possible to strip debug information from a PE file and store it in a debug file (.DBG) for use by debuggers. To do this, a debugger needs to know whether to find the debug information in a separate file or not and whether the information has been stripped from the file or not. A debugger could find out by drilling down into the executable file looking for debug information. To save the debugger from having to search the file, a file characteristic that indicates that the file has been stripped (IMAGE_FILE_DEBUG_STRIPPED) was invented. Debuggers can look in the PE file header to quickly determine whether the debug information is present in the file or not. WINNT.H defines several other flags that indicate file header information much the way the example described above does. I’ll leave it as an exercise for the reader t o look up the flags to see if any of them are interesting or not. They are located in WINNT.H immediately after the "
            ],
            [
              "IMAGE_FILE_HEADER",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure described above. One other useful entry in the PE file header structure is the "
            ],
            [
              "NumberOfSections",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field. It turns out that you need to know how many sections–more specifically, how many section headers and section bodies–are in the file in order to extract the information easily. Each section header and section body is laid out sequentially in the file, so the number of sections is necessary to determine where the section headers and bodies end. The following function extracts the number of sections from the PE file header:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Notice that the size of the file header structure is conveniently defined in the include file… The information in the PE file is basically high-level information that is used by the system or applications to determine how to treat the file. The first field is used to indicate what type of machine the executable was built for, such as the DEC® Alpha, MIPS R4000, Intel® x86, or some other processor. The system uses this information to quickly determine how to treat the file before going any further into the rest of the file data. The "
          },
          {
            "Text": "Characteristics",
            "AttrFlags": 4
          },
          {
            "Text": " field identifies specific characteristics about the file. For example, consider how separate debug files are managed for an executable. It is possible to strip debug information from a PE file and store it in a debug file (.DBG) for use by debuggers. To do this, a debugger needs to know whether to find the debug information in a separate file or not and whether the information has been stripped from the file or not. A debugger could find out by drilling down into the executable file looking for debug information. To save the debugger from having to search the file, a file characteristic that indicates that the file has been stripped (IMAGE_FILE_DEBUG_STRIPPED) was invented. Debuggers can look in the PE file header to quickly determine whether the debug information is present in the file or not. WINNT.H defines several other flags that indicate file header information much the way the example described above does. I’ll leave it as an exercise for the reader t o look up the flags to see if any of them are interesting or not. They are located in WINNT.H immediately after the "
          },
          {
            "Text": "IMAGE_FILE_HEADER",
            "AttrFlags": 1
          },
          {
            "Text": " structure described above. One other useful entry in the PE file header structure is the "
          },
          {
            "Text": "NumberOfSections",
            "AttrFlags": 4
          },
          {
            "Text": " field. It turns out that you need to know how many sections–more specifically, how many section headers and section bodies–are in the file in order to extract the information easily. Each section header and section body is laid out sequentially in the file, so the number of sections is necessary to determine where the section headers and bodies end. The following function extracts the number of sections from the PE file header:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938410,
        "id": "ab3d653f-c514-4684-92ae-69822fd07e12",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938410,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int   WINAPI NumOfSections (\n    LPVOID    lpFile)\n{\n    /* Number of sections is indicated in file header. */\n    return (int)((PIMAGE_FILE_HEADER)\n                  PEFHDROFFSET (lpFile))-\u003eNumberOfSections);\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int   WINAPI NumOfSections (\n    LPVOID    lpFile)\n{\n    /* Number of sections is indicated in file header. */\n    return (int)((PIMAGE_FILE_HEADER)\n                  PEFHDROFFSET (lpFile))-\u003eNumberOfSections);\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938410,
        "id": "f974dec3-a8cd-4260-a6c8-521b58b36c68",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938410,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As you can see, the "
            ],
            [
              "PEFHDROFFSET",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and the other macros are pretty handy to have around."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As you can see, the "
          },
          {
            "Text": "PEFHDROFFSET",
            "AttrFlags": 1
          },
          {
            "Text": " and the other macros are pretty handy to have around."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938410,
        "id": "5c7c6d2f-2f81-4df5-8ac1-42196c5d2e2e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938410,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "PE Optional Header"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "PE Optional Header"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938411,
        "id": "8f57f678-72f9-41fc-8f15-1fee58141bd8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938411,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The next 224 bytes in the executable file make up the PE optional header. Though its name is “optional header,” rest assured that this is not an optional entry in PE executable files. A pointer to the optional header is obtained with the "
            ],
            [
              "OPTHDROFFSET",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " macro:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The next 224 bytes in the executable file make up the PE optional header. Though its name is “optional header,” rest assured that this is not an optional entry in PE executable files. A pointer to the optional header is obtained with the "
          },
          {
            "Text": "OPTHDROFFSET",
            "AttrFlags": 1
          },
          {
            "Text": " macro:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938411,
        "id": "767c583c-5f7a-4788-976d-d9e0dded00b1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938411,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a                 + \\\n    ((PIMAGE_DOS_HEADER)a)-\u003ee_lfanew + SIZE_OF_NT_SIGNATURE + \\\n    sizeof (IMAGE_FILE_HEADER)))"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a                 + \\\n    ((PIMAGE_DOS_HEADER)a)-\u003ee_lfanew + SIZE_OF_NT_SIGNATURE + \\\n    sizeof (IMAGE_FILE_HEADER)))",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938411,
        "id": "37cd6c22-7875-493c-9300-e4cbc117b6ec",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938411,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The optional header contains most of the meaningful information about the executable image, such as initial stack size, program entry point location, preferred base address, operating system version, section alignment information, and so forth. The "
            ],
            [
              "IMAGE_OPTIONAL_HEADER",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure represents the optional header as follows: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The optional header contains most of the meaningful information about the executable image, such as initial stack size, program entry point location, preferred base address, operating system version, section alignment information, and so forth. The "
          },
          {
            "Text": "IMAGE_OPTIONAL_HEADER",
            "AttrFlags": 1
          },
          {
            "Text": " structure represents the optional header as follows: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938411,
        "id": "fb4d8126-ab19-4411-9c2e-8925050a610e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938411,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n    USHORT  Magic;\n    UCHAR   MajorLinkerVersion;\n    UCHAR   MinorLinkerVersion;\n    ULONG   SizeOfCode;\n    ULONG   SizeOfInitializedData;\n    ULONG   SizeOfUninitializedData;\n    ULONG   AddressOfEntryPoint;\n    ULONG   BaseOfCode;\n    ULONG   BaseOfData;\n    //\n    // NT additional fields.\n    //\n    ULONG   ImageBase;\n    ULONG   SectionAlignment;\n    ULONG   FileAlignment;\n    USHORT  MajorOperatingSystemVersion;\n    USHORT  MinorOperatingSystemVersion;\n    USHORT  MajorImageVersion;\n    USHORT  MinorImageVersion;\n    USHORT  MajorSubsystemVersion;\n    USHORT  MinorSubsystemVersion;\n    ULONG   Reserved1;\n    ULONG   SizeOfImage;\n    ULONG   SizeOfHeaders;\n    ULONG   CheckSum;\n    USHORT  Subsystem;\n    USHORT  DllCharacteristics;\n    ULONG   SizeOfStackReserve;\n    ULONG   SizeOfStackCommit;\n    ULONG   SizeOfHeapReserve;\n    ULONG   SizeOfHeapCommit;\n    ULONG   LoaderFlags;\n    ULONG   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_OPTIONAL_HEADER {\n    //\n    // Standard fields.\n    //\n    USHORT  Magic;\n    UCHAR   MajorLinkerVersion;\n    UCHAR   MinorLinkerVersion;\n    ULONG   SizeOfCode;\n    ULONG   SizeOfInitializedData;\n    ULONG   SizeOfUninitializedData;\n    ULONG   AddressOfEntryPoint;\n    ULONG   BaseOfCode;\n    ULONG   BaseOfData;\n    //\n    // NT additional fields.\n    //\n    ULONG   ImageBase;\n    ULONG   SectionAlignment;\n    ULONG   FileAlignment;\n    USHORT  MajorOperatingSystemVersion;\n    USHORT  MinorOperatingSystemVersion;\n    USHORT  MajorImageVersion;\n    USHORT  MinorImageVersion;\n    USHORT  MajorSubsystemVersion;\n    USHORT  MinorSubsystemVersion;\n    ULONG   Reserved1;\n    ULONG   SizeOfImage;\n    ULONG   SizeOfHeaders;\n    ULONG   CheckSum;\n    USHORT  Subsystem;\n    USHORT  DllCharacteristics;\n    ULONG   SizeOfStackReserve;\n    ULONG   SizeOfStackCommit;\n    ULONG   SizeOfHeapReserve;\n    ULONG   SizeOfHeapCommit;\n    ULONG   LoaderFlags;\n    ULONG   NumberOfRvaAndSizes;\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938412,
        "id": "9725ccc7-acbe-45c6-9882-afead65135e2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938412,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As you can see, the list of fields in this structure is rather lengthy. Rather than bore you with descriptions of all of these fields, I’ll simply discuss the useful ones–that is, useful in the context of exploring the PE file format."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As you can see, the list of fields in this structure is rather lengthy. Rather than bore you with descriptions of all of these fields, I’ll simply discuss the useful ones–that is, useful in the context of exploring the PE file format."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938412,
        "id": "7b7300fc-cc85-429e-a6fa-4335a3c42d2c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938412,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Standard Fields"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Standard Fields"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938412,
        "id": "37425840-3c95-4310-bb86-541dddcec88a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938412,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "First, note that the structure is divided into “Standard fields” and “NT additional fields.” The standard fields are those common to the Common Object File Format (COFF), which most UNIX executable files use. Though the standard fields retain the names defined in COFF, Windows NT actually uses some of them for different purposes that would be better described with other names."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "First, note that the structure is divided into “Standard fields” and “NT additional fields.” The standard fields are those common to the Common Object File Format (COFF), which most UNIX executable files use. Though the standard fields retain the names defined in COFF, Windows NT actually uses some of them for different purposes that would be better described with other names."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938413,
        "id": "2a28bd1f-4cee-487f-9821-a88f2b196cc3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938413,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Magic",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". I was unable to track down what this field is used for."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Magic",
            "AttrFlags": 4
          },
          {
            "Text": ". I was unable to track down what this field is used for."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938414,
        "id": "f6cabb8d-e406-4b70-8021-db6395942db8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938414,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MajorLinkerVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "MinorLinkerVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Indicates version of the linker that linked this image."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MajorLinkerVersion",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "MinorLinkerVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Indicates version of the linker that linked this image."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938414,
        "id": "94d88750-45de-40d4-9fb2-f7659bee4951",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938414,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfCode",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Size of executable code."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfCode",
            "AttrFlags": 4
          },
          {
            "Text": ". Size of executable code."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938415,
        "id": "81cae7d8-9fb4-457e-bf13-f3f0c95d8901",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938415,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfInitializedData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Size of initialized data."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfInitializedData",
            "AttrFlags": 4
          },
          {
            "Text": ". Size of initialized data."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938415,
        "id": "a07ed5ff-e9b6-4a2d-a32f-6b2c441c88b2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938415,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfUninitializedData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Size of uninitialized data."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfUninitializedData",
            "AttrFlags": 4
          },
          {
            "Text": ". Size of uninitialized data."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938416,
        "id": "8310de26-9916-4899-a02f-9229f02e47a1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938416,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "AddressOfEntryPoint",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Of the standard fields, the "
            ],
            [
              "AddressOfEntryPoint",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is the most interesting for the PE file format. This field indicates the location of the entry point for the application and, perhaps more importantly to system hackers, the location of the end of the Import Address Table (IAT). The following function demonstrates how to retrieve the entry point of a Windows NT executable image from the optional header."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "AddressOfEntryPoint",
            "AttrFlags": 4
          },
          {
            "Text": ". Of the standard fields, the "
          },
          {
            "Text": "AddressOfEntryPoint",
            "AttrFlags": 4
          },
          {
            "Text": " field is the most interesting for the PE file format. This field indicates the location of the entry point for the application and, perhaps more importantly to system hackers, the location of the end of the Import Address Table (IAT). The following function demonstrates how to retrieve the entry point of a Windows NT executable image from the optional header."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938416,
        "id": "8730548a-9a83-4476-8599-1ac7d2d61886",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938416,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "LPVOID  WINAPI GetModuleEntryPoint (\n    LPVOID    lpFile)\n{\n    PIMAGE_OPTIONAL_HEADER   poh;\n\n    poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);\n\n    if (poh != NULL)\n        return (LPVOID)poh-\u003eAddressOfEntryPoint;\n    else\n        return NULL;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "LPVOID  WINAPI GetModuleEntryPoint (\n    LPVOID    lpFile)\n{\n    PIMAGE_OPTIONAL_HEADER   poh;\n\n    poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);\n\n    if (poh != NULL)\n        return (LPVOID)poh-\u003eAddressOfEntryPoint;\n    else\n        return NULL;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938416,
        "id": "559b88e8-0e45-46d4-a46d-d9b83b0737ee",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938416,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "BaseOfCode",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Relative offset of code (“.text” section) in loaded image."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "BaseOfCode",
            "AttrFlags": 4
          },
          {
            "Text": ". Relative offset of code (“.text” section) in loaded image."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938416,
        "id": "8f4f2967-7037-490b-b739-e35ba4adfb61",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938416,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "BaseOfData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Relative offset of uninitialized data (“.bss” section) in loaded image."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "BaseOfData",
            "AttrFlags": 4
          },
          {
            "Text": ". Relative offset of uninitialized data (“.bss” section) in loaded image."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938416,
        "id": "4fe77032-792d-4dc7-b3fc-506c1687465c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938416,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Windows NT Additional Fields"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Windows NT Additional Fields"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938417,
        "id": "c26852ca-5658-4f9a-a414-8cc129414794",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938417,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The additional fields added to the Windows NT PE file format provide loader support for much of the Windows NT-specific process behavior. Following is a summary of these fields."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The additional fields added to the Windows NT PE file format provide loader support for much of the Windows NT-specific process behavior. Following is a summary of these fields."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938417,
        "id": "3422445e-7b32-4906-ba7a-414ffc09ddc2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938417,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "ImageBase",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Preferred base address in the address space of a process to map the executable image to. The linker defaults to 0x00400000, but you can override the default with the "
            ],
            [
              "-BASE: linker",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " switch."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "ImageBase",
            "AttrFlags": 4
          },
          {
            "Text": ". Preferred base address in the address space of a process to map the executable image to. The linker defaults to 0x00400000, but you can override the default with the "
          },
          {
            "Text": "-BASE: linker",
            "AttrFlags": 1
          },
          {
            "Text": " switch."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938418,
        "id": "8a750732-8764-4bba-ac84-78f605b909ac",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938418,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SectionAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Each section is loaded into the address space of a process sequentially, beginning at "
            ],
            [
              "ImageBase",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". "
            ],
            [
              "SectionAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " dictates the minimum amount of space a section can occupy when loaded–that is, sections are aligned on "
            ],
            [
              "SectionAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " boundaries. Section alignment can be no less than the page size (currently 4096 bytes on the "
            ],
            [
              "x",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "86 platform) and must be a multiple of the page size as dictated by the behavior of Windows NT’s virtual memory manager. 4096 bytes is the "
            ],
            [
              "x",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "86 linker default, but this can be set using the "
            ],
            [
              "-ALIGN: linker",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " switch."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SectionAlignment",
            "AttrFlags": 4
          },
          {
            "Text": ". Each section is loaded into the address space of a process sequentially, beginning at "
          },
          {
            "Text": "ImageBase",
            "AttrFlags": 4
          },
          {
            "Text": ". "
          },
          {
            "Text": "SectionAlignment",
            "AttrFlags": 4
          },
          {
            "Text": " dictates the minimum amount of space a section can occupy when loaded–that is, sections are aligned on "
          },
          {
            "Text": "SectionAlignment",
            "AttrFlags": 4
          },
          {
            "Text": " boundaries. Section alignment can be no less than the page size (currently 4096 bytes on the "
          },
          {
            "Text": "x",
            "AttrFlags": 4
          },
          {
            "Text": "86 platform) and must be a multiple of the page size as dictated by the behavior of Windows NT’s virtual memory manager. 4096 bytes is the "
          },
          {
            "Text": "x",
            "AttrFlags": 4
          },
          {
            "Text": "86 linker default, but this can be set using the "
          },
          {
            "Text": "-ALIGN: linker",
            "AttrFlags": 1
          },
          {
            "Text": " switch."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938419,
        "id": "002f0edc-e316-4722-a104-84c2a21e2d25",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938419,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "FileAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Minimum granularity of chunks of information within the image file prior to loading. For example, the linker zero-pads a section body (raw data for a section) up to the nearest "
            ],
            [
              "FileAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " boundary in the file. This value is constrained to be a power of 2 between 512 and 65,535."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "FileAlignment",
            "AttrFlags": 4
          },
          {
            "Text": ". Minimum granularity of chunks of information within the image file prior to loading. For example, the linker zero-pads a section body (raw data for a section) up to the nearest "
          },
          {
            "Text": "FileAlignment",
            "AttrFlags": 4
          },
          {
            "Text": " boundary in the file. This value is constrained to be a power of 2 between 512 and 65,535."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938419,
        "id": "0aeb092f-21a6-4167-84a4-c861a723f734",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938419,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MajorOperatingSystemVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Indicates the major version of the Windows NT operating system."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MajorOperatingSystemVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Indicates the major version of the Windows NT operating system."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938420,
        "id": "6cc718e8-27f8-4baa-bf79-71ae746df9ea",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938420,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MinorOperatingSystemVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Indicates the minor version of the Windows NT operating system."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MinorOperatingSystemVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Indicates the minor version of the Windows NT operating system."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938420,
        "id": "b1b87bb3-8bd5-42b6-89c6-cdef6d822e4e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938420,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MajorImageVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Used to indicate the major version number of the application."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MajorImageVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Used to indicate the major version number of the application."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938420,
        "id": "2c4b59dc-6e5f-4ee9-834d-cb23807d7b38",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938420,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MinorImageVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Used to indicate the minor version number of the application."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MinorImageVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Used to indicate the minor version number of the application."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938421,
        "id": "5358f950-4ea2-4b35-b41d-45afc88e14ce",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938421,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MajorSubsystemVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Indicates the Windows NT Win32 subsystem major version number."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MajorSubsystemVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Indicates the Windows NT Win32 subsystem major version number."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938421,
        "id": "f01421ea-50bb-4fe3-9c5d-712b76cfabd9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938421,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "MinorSubsystemVersion",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Indicates the Windows NT Win32 subsystem minor version number."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "MinorSubsystemVersion",
            "AttrFlags": 4
          },
          {
            "Text": ". Indicates the Windows NT Win32 subsystem minor version number."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938421,
        "id": "a307eae6-fd0b-42c3-950e-49dc2ed47df7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938421,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Reserved1",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Unknown purpose, currently not used by the system and set to zero by the linker."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Reserved1",
            "AttrFlags": 4
          },
          {
            "Text": ". Unknown purpose, currently not used by the system and set to zero by the linker."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938424,
        "id": "b5c61c57-a3f3-41b7-b61d-265b91ab2609",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938424,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfImage",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Indicates the amount of address space to reserve in the address space for the loaded executable image. This number is influenced greatly by "
            ],
            [
              "SectionAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". For example, consider a system having a fixed page size of 4096 bytes. If you have an executable with 11 sections, each less than 4096 bytes, aligned on a 65,536-byte boundary, the "
            ],
            [
              "SizeOfImage",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field would be set to 11 * 65,536 = 720,896 (176 pages). The same file linked with 4096-byte alignment would result in 11 * 4096 = 45,056 (11 pages) for the "
            ],
            [
              "SizeOfImage",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field. This is a simple example in which each section requires less than a page of memory. In reality, the linker determines the exact "
            ],
            [
              "SizeOfImage",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " by figuring each section individually. It first determines how many bytes the section requires, then it rounds up to the nearest page boundary, and finally it rounds page count to the nearest "
            ],
            [
              "SectionAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " boundary. The total is then the sum of each section’s individual requirement."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfImage",
            "AttrFlags": 4
          },
          {
            "Text": ". Indicates the amount of address space to reserve in the address space for the loaded executable image. This number is influenced greatly by "
          },
          {
            "Text": "SectionAlignment",
            "AttrFlags": 4
          },
          {
            "Text": ". For example, consider a system having a fixed page size of 4096 bytes. If you have an executable with 11 sections, each less than 4096 bytes, aligned on a 65,536-byte boundary, the "
          },
          {
            "Text": "SizeOfImage",
            "AttrFlags": 4
          },
          {
            "Text": " field would be set to 11 * 65,536 = 720,896 (176 pages). The same file linked with 4096-byte alignment would result in 11 * 4096 = 45,056 (11 pages) for the "
          },
          {
            "Text": "SizeOfImage",
            "AttrFlags": 4
          },
          {
            "Text": " field. This is a simple example in which each section requires less than a page of memory. In reality, the linker determines the exact "
          },
          {
            "Text": "SizeOfImage",
            "AttrFlags": 4
          },
          {
            "Text": " by figuring each section individually. It first determines how many bytes the section requires, then it rounds up to the nearest page boundary, and finally it rounds page count to the nearest "
          },
          {
            "Text": "SectionAlignment",
            "AttrFlags": 4
          },
          {
            "Text": " boundary. The total is then the sum of each section’s individual requirement."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938424,
        "id": "e3223ca4-e049-41b3-b1d9-ca904c71fb4d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938424,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfHeaders",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". This field indicates how much space in the file is used for representing all the file headers, including the MS-DOS header, PE file header, PE optional header, and PE section headers. The section bodies begin at this location in the file."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfHeaders",
            "AttrFlags": 4
          },
          {
            "Text": ". This field indicates how much space in the file is used for representing all the file headers, including the MS-DOS header, PE file header, PE optional header, and PE section headers. The section bodies begin at this location in the file."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938424,
        "id": "875ebbf9-0d76-4f5e-8703-6603df878c18",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938424,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "CheckSum",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". A checksum value is used to validate the executable file at load time. The value is set and verified by the linker. The algorithm used for creating these checksum values is proprietary information and will not be published."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "CheckSum",
            "AttrFlags": 4
          },
          {
            "Text": ". A checksum value is used to validate the executable file at load time. The value is set and verified by the linker. The algorithm used for creating these checksum values is proprietary information and will not be published."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938425,
        "id": "a03b662f-9248-4ec3-abf4-7037e2634079",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938425,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Subsystem",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Field used to identify the target subsystem for this executable. Each of the possible subsystem values are listed in the WINNT.H file immediately after the "
            ],
            [
              "IMAGE_OPTIONAL_HEADER",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Subsystem",
            "AttrFlags": 4
          },
          {
            "Text": ". Field used to identify the target subsystem for this executable. Each of the possible subsystem values are listed in the WINNT.H file immediately after the "
          },
          {
            "Text": "IMAGE_OPTIONAL_HEADER",
            "AttrFlags": 1
          },
          {
            "Text": " structure."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938425,
        "id": "b0ddfc3f-1ee9-48a7-bfd3-1984b52528c3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938425,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "DllCharacteristics",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Flags used to indicate if a DLL image includes entry points for process and thread initialization and termination."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "DllCharacteristics",
            "AttrFlags": 4
          },
          {
            "Text": ". Flags used to indicate if a DLL image includes entry points for process and thread initialization and termination."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938426,
        "id": "244d3a6a-594d-4dcf-bc25-852b4d63f408",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938426,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfStackReserve",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "SizeOfStackCommit",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "SizeOfHeapReserve",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "S izeOfHeapCommit",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". These fields control the amount of address space to reserve and commit for the stack and default heap. Both the stack and heap have default values of 1 page committed and 16 pages reserved. These values are set with the linker switches "
            ],
            [
              "-STACKSIZE:",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "-HEAPSIZE:",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfStackReserve",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "SizeOfStackCommit",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "SizeOfHeapReserve",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "S izeOfHeapCommit",
            "AttrFlags": 4
          },
          {
            "Text": ". These fields control the amount of address space to reserve and commit for the stack and default heap. Both the stack and heap have default values of 1 page committed and 16 pages reserved. These values are set with the linker switches "
          },
          {
            "Text": "-STACKSIZE:",
            "AttrFlags": 1
          },
          {
            "Text": " and "
          },
          {
            "Text": "-HEAPSIZE:",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938426,
        "id": "4f733808-840b-43ad-8451-df0dee012c95",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938426,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "LoaderFlags",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Tells the loader whether to break on load, debug on load, or the default, which is to let things run normally."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "LoaderFlags",
            "AttrFlags": 4
          },
          {
            "Text": ". Tells the loader whether to break on load, debug on load, or the default, which is to let things run normally."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938427,
        "id": "4da12a54-38a6-48db-99db-42dff6d73ec0",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938427,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "NumberOfRvaAndSizes",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". This field identifies the length of the "
            ],
            [
              "DataDirectory",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " array that follows. It is important to note that this field is used to identify the size of the array, not the number of valid entries in the array."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "NumberOfRvaAndSizes",
            "AttrFlags": 4
          },
          {
            "Text": ". This field identifies the length of the "
          },
          {
            "Text": "DataDirectory",
            "AttrFlags": 4
          },
          {
            "Text": " array that follows. It is important to note that this field is used to identify the size of the array, not the number of valid entries in the array."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938427,
        "id": "b6633d65-8e57-4f5e-9fab-f292d942ba0d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938427,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "DataDirectory",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". The data directory indicates where to find other important components of executable information in the file. It is really nothing more than an array of "
            ],
            [
              "IMAGE_DATA_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structures that are located at the end of the optional header structure. The current PE file format defines 16 possible data directories, 11 of which are now being used."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "DataDirectory",
            "AttrFlags": 4
          },
          {
            "Text": ". The data directory indicates where to find other important components of executable information in the file. It is really nothing more than an array of "
          },
          {
            "Text": "IMAGE_DATA_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": " structures that are located at the end of the optional header structure. The current PE file format defines 16 possible data directories, 11 of which are now being used."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938428,
        "id": "871b1b8b-1c37-41ff-af2f-e99aa8348693",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938428,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Data Directories"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Data Directories"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938428,
        "id": "9d0df0ea-fd97-44be-8cde-f7d584925a2e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938428,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As defined in WINNT.H, the data directories are: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As defined in WINNT.H, the data directories are: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938428,
        "id": "80e61c4d-1a34-412a-9e70-530154235705",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938428,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "// Directory Entries\n\n// Export Directory\n#define IMAGE_DIRECTORY_ENTRY_EXPORT         0\n// Import Directory\n#define IMAGE_DIRECTORY_ENTRY_IMPORT         1\n// Resource Directory\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2\n// Exception Directory\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3\n// Security Directory\n#define IMAGE_DIRECTORY_ENTRY_SECURITY       4\n// Base Relocation Table\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5\n// Debug Directory\n#define IMAGE_DIRECTORY_ENTRY_DEBUG          6\n// Description String\n#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7\n// Machine Value (MIPS GP)\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8\n// TLS Directory\n#define IMAGE_DIRECTORY_ENTRY_TLS            9\n// Load Configuration Directory\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "// Directory Entries\n\n// Export Directory\n#define IMAGE_DIRECTORY_ENTRY_EXPORT         0\n// Import Directory\n#define IMAGE_DIRECTORY_ENTRY_IMPORT         1\n// Resource Directory\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2\n// Exception Directory\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3\n// Security Directory\n#define IMAGE_DIRECTORY_ENTRY_SECURITY       4\n// Base Relocation Table\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5\n// Debug Directory\n#define IMAGE_DIRECTORY_ENTRY_DEBUG          6\n// Description String\n#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7\n// Machine Value (MIPS GP)\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8\n// TLS Directory\n#define IMAGE_DIRECTORY_ENTRY_TLS            9\n// Load Configuration Directory\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938428,
        "id": "961ddacb-b8dd-43fe-88cc-e794a5fd324c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938428,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Each data directory is basically a structure defined as an "
            ],
            [
              "IMAGE_DATA_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ". And although data directory entries themselves are the same, each specific directory type is entirely unique. The definition of each defined data directory is described in “Predefined Sections” later in this article. "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Each data directory is basically a structure defined as an "
          },
          {
            "Text": "IMAGE_DATA_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": ". And although data directory entries themselves are the same, each specific directory type is entirely unique. The definition of each defined data directory is described in “Predefined Sections” later in this article. "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938428,
        "id": "047bf3ad-855b-465e-91ef-acb6b094f156",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938428,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_DATA_DIRECTORY {\n    ULONG   VirtualAddress;\n    ULONG   Size;\n} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_DATA_DIRECTORY {\n    ULONG   VirtualAddress;\n    ULONG   Size;\n} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938429,
        "id": "11d3c228-bc01-4757-87b2-e8967b26b2a3",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938429,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Each data directory entry specifies the size and relative virtual address of the directory. To locate a particular directory, you determine the relative address from the data directory array in the optional header. Then use the virtual address to determine which section the directory is in. Once you determine which section contains the directory, the section header for that section is then used to find the exact file offset location of the data directory. So to get a data directory, you first need to know about sections, which are described next. An example of how to locate data directories immediately follows this discussion."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Each data directory entry specifies the size and relative virtual address of the directory. To locate a particular directory, you determine the relative address from the data directory array in the optional header. Then use the virtual address to determine which section the directory is in. Once you determine which section contains the directory, the section header for that section is then used to find the exact file offset location of the data directory. So to get a data directory, you first need to know about sections, which are described next. An example of how to locate data directories immediately follows this discussion."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938429,
        "id": "26a9e234-53d1-4140-be0a-bcfd9baae782",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938429,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "PE File Sections"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "PE File Sections"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938429,
        "id": "190b7c4d-8228-4602-835a-dce7842b23fd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938429,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The PE file specification consists of the headers defined so far and a generic object called a "
            ],
            [
              "section",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Sections contain the content of the file, including code, data, resources, and other executable information. Each section has a header and a body (the raw data). Section headers are described below, but section bodies lack a rigid file structure. They can be organized in almost any way a linker wishes to organize them, as long as the header is filled with enough information to be able to decipher the data."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The PE file specification consists of the headers defined so far and a generic object called a "
          },
          {
            "Text": "section",
            "AttrFlags": 4
          },
          {
            "Text": ". Sections contain the content of the file, including code, data, resources, and other executable information. Each section has a header and a body (the raw data). Section headers are described below, but section bodies lack a rigid file structure. They can be organized in almost any way a linker wishes to organize them, as long as the header is filled with enough information to be able to decipher the data."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938429,
        "id": "df800f4d-e67b-41bd-984a-b8de6c6bbdb8",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938429,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Section Headers"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Section Headers"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938429,
        "id": "b8f46bd3-4e20-4723-99b6-0c53db94c896",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938429,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Section headers are located sequentially right after the optional header in the PE file format. Each section header is 40 bytes with no padding between them. Section headers are defined as in the following structure: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Section headers are located sequentially right after the optional header in the PE file format. Each section header is 40 bytes with no padding between them. Section headers are defined as in the following structure: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938429,
        "id": "ffa69c8b-f12d-4002-835e-3eac4fe5de7a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938429,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#define IMAGE_SIZEOF_SHORT_NAME              8\n\ntypedef struct _IMAGE_SECTION_HEADER {\n    UCHAR   Name[IMAGE_SIZEOF_SHORT_NAME];\n    union {\n            ULONG   PhysicalAddress;\n            ULONG   VirtualSize;\n    } Misc;\n    ULONG   VirtualAddress;\n    ULONG   SizeOfRawData;\n    ULONG   PointerToRawData;\n    ULONG   PointerToRelocations;\n    ULONG   PointerToLinenumbers;\n    USHORT  NumberOfRelocations;\n    USHORT  NumberOfLinenumbers;\n    ULONG   Characteristics;\n} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#define IMAGE_SIZEOF_SHORT_NAME              8\n\ntypedef struct _IMAGE_SECTION_HEADER {\n    UCHAR   Name[IMAGE_SIZEOF_SHORT_NAME];\n    union {\n            ULONG   PhysicalAddress;\n            ULONG   VirtualSize;\n    } Misc;\n    ULONG   VirtualAddress;\n    ULONG   SizeOfRawData;\n    ULONG   PointerToRawData;\n    ULONG   PointerToRelocations;\n    ULONG   PointerToLinenumbers;\n    USHORT  NumberOfRelocations;\n    USHORT  NumberOfLinenumbers;\n    ULONG   Characteristics;\n} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938430,
        "id": "763d2cfc-196a-492a-8094-c13f47b7f846",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938430,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "How do you go about getting section header information for a particular section? Since section headers are organized sequentially in no specific order, section headers must be located by name. The following function shows how to retrieve a section header from a PE image file given the name of the section:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "How do you go about getting section header information for a particular section? Since section headers are organized sequentially in no specific order, section headers must be located by name. The following function shows how to retrieve a section header from a PE image file given the name of the section:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938430,
        "id": "180a5fa3-6560-40ce-ae62-569d751dc529",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938430,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "BOOL    WINAPI GetSectionHdrByName (\n    LPVOID                   lpFile,\n    IMAGE_SECTION_HEADER     *sh,\n    char                     *szSection)\n{\n    PIMAGE_SECTION_HEADER    psh;\n    int                      nSections = NumOfSections (lpFile);\n    int                      i;\n\n\n    if ((psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) !=\n         NULL)\n        {\n        /* find the section by name */\n        for (i=0; i\u003cnSections; i++)\n            {\n            if (!strcmp (psh-\u003eName, szSection))\n                {\n                /* copy data to header */\n                CopyMemory ((LPVOID)sh,\n                            (LPVOID)psh,\n                            sizeof (IMAGE_SECTION_HEADER));\n                return TRUE;\n                }\n            else\n                psh++;\n            }\n        }\n\n    return FALSE;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "BOOL    WINAPI GetSectionHdrByName (\n    LPVOID                   lpFile,\n    IMAGE_SECTION_HEADER     *sh,\n    char                     *szSection)\n{\n    PIMAGE_SECTION_HEADER    psh;\n    int                      nSections = NumOfSections (lpFile);\n    int                      i;\n\n\n    if ((psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) !=\n         NULL)\n        {\n        /* find the section by name */\n        for (i=0; i\u003cnSections; i++)\n            {\n            if (!strcmp (psh-\u003eName, szSection))\n                {\n                /* copy data to header */\n                CopyMemory ((LPVOID)sh,\n                            (LPVOID)psh,\n                            sizeof (IMAGE_SECTION_HEADER));\n                return TRUE;\n                }\n            else\n                psh++;\n            }\n        }\n\n    return FALSE;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938430,
        "id": "768a3e9e-805a-4ff6-bfed-3ccb8fc3b7ee",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938430,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The function simply locates the first section header via the "
            ],
            [
              "SECHDROFFSET",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " macro. Then the function loops through each section, comparing each section’s name with the name of the section it’s looking for, until it finds the right one. When the section is found, the function copies the data from the memory-mapped file to the structure passed in to the function. The fields of the "
            ],
            [
              "IMAGE_SECTION_HEADER",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure can then be accessed directly from the structure."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The function simply locates the first section header via the "
          },
          {
            "Text": "SECHDROFFSET",
            "AttrFlags": 1
          },
          {
            "Text": " macro. Then the function loops through each section, comparing each section’s name with the name of the section it’s looking for, until it finds the right one. When the section is found, the function copies the data from the memory-mapped file to the structure passed in to the function. The fields of the "
          },
          {
            "Text": "IMAGE_SECTION_HEADER",
            "AttrFlags": 1
          },
          {
            "Text": " structure can then be accessed directly from the structure."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938430,
        "id": "b9e8bc84-5296-4bc1-aa4f-f9f1bd84bb6a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938430,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Section Header Fields"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Section Header Fields"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938431,
        "id": "09ad2a20-61f2-4972-90c5-f4e1b81622bd",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938431,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Each section header has a "
            ],
            [
              "name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field up to eight characters long, for which the first character must be a period."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": ". Each section header has a "
          },
          {
            "Text": "name",
            "AttrFlags": 4
          },
          {
            "Text": " field up to eight characters long, for which the first character must be a period."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938431,
        "id": "e05c0c05-ecb4-489d-9227-a0e26680bf44",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938431,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "PhysicalAddress",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " "
            ],
            [
              "or",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " "
            ],
            [
              "VirtualSize",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". The second field is a union field that is not currently used."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "PhysicalAddress",
            "AttrFlags": 4
          },
          {
            "Text": " "
          },
          {
            "Text": "or",
            "AttrFlags": 1
          },
          {
            "Text": " "
          },
          {
            "Text": "VirtualSize",
            "AttrFlags": 4
          },
          {
            "Text": ". The second field is a union field that is not currently used."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938432,
        "id": "aae320e6-d0a1-4e39-953c-ef9ecb4354f2",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938432,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "VirtualAddress",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". This field identifies the virtual address in the process’s address space to which to load the section. The actual address is created by taking the value of this field and adding it to the "
            ],
            [
              "ImageBase",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " virtual address in the optional header structure. Keep in mind, though, that if this image file represents a DLL, there is no guarantee that the DLL will be loaded to the "
            ],
            [
              "ImageBase",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " location requested. So once the file is loaded into a process, the actual "
            ],
            [
              "ImageBase",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " value should be verified programmatically using "
            ],
            [
              "GetModuleHandle",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "VirtualAddress",
            "AttrFlags": 4
          },
          {
            "Text": ". This field identifies the virtual address in the process’s address space to which to load the section. The actual address is created by taking the value of this field and adding it to the "
          },
          {
            "Text": "ImageBase",
            "AttrFlags": 4
          },
          {
            "Text": " virtual address in the optional header structure. Keep in mind, though, that if this image file represents a DLL, there is no guarantee that the DLL will be loaded to the "
          },
          {
            "Text": "ImageBase",
            "AttrFlags": 4
          },
          {
            "Text": " location requested. So once the file is loaded into a process, the actual "
          },
          {
            "Text": "ImageBase",
            "AttrFlags": 4
          },
          {
            "Text": " value should be verified programmatically using "
          },
          {
            "Text": "GetModuleHandle",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938433,
        "id": "fc01b9b6-c0c1-4375-8979-06d7b97922af",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938433,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "SizeOfRawData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". This field indicates the "
            ],
            [
              "FileAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "-relative size of the section body. The actual size of the section body will be less than or equal to a multiple of "
            ],
            [
              "FileAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " in the file. Once the image is loaded into a process’s address space, the size of the section body becomes less than or equal to a multiple of "
            ],
            [
              "SectionAlignment",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "SizeOfRawData",
            "AttrFlags": 4
          },
          {
            "Text": ". This field indicates the "
          },
          {
            "Text": "FileAlignment",
            "AttrFlags": 4
          },
          {
            "Text": "-relative size of the section body. The actual size of the section body will be less than or equal to a multiple of "
          },
          {
            "Text": "FileAlignment",
            "AttrFlags": 4
          },
          {
            "Text": " in the file. Once the image is loaded into a process’s address space, the size of the section body becomes less than or equal to a multiple of "
          },
          {
            "Text": "SectionAlignment",
            "AttrFlags": 4
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938433,
        "id": "e668209b-e298-40cb-9768-a2f0b7708666",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938433,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "PointerToRawData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". This is an offset to the location of the section body in the file."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "PointerToRawData",
            "AttrFlags": 4
          },
          {
            "Text": ". This is an offset to the location of the section body in the file."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938435,
        "id": "fabc50a6-7f2e-46f4-a131-41aafe9b7489",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938435,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "PointerToRelocations",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "PointerToLinenumbers",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "NumberOfRelocations",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "NumberOfLinenumbers",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". None of these fi elds are used in the PE file format."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "PointerToRelocations",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "PointerToLinenumbers",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "NumberOfRelocations",
            "AttrFlags": 4
          },
          {
            "Text": ", "
          },
          {
            "Text": "NumberOfLinenumbers",
            "AttrFlags": 4
          },
          {
            "Text": ". None of these fi elds are used in the PE file format."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938436,
        "id": "061b6ac3-7c0c-421c-8d22-ffd1421a2192",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938436,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Characteristics",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Defines the section characteristics. These values are found both in WINNT.H and in the Portable Executable Format specification located on this CD."
            ]
          ]
        },
        "type": "bulleted_list",
        "version": 1,
        "inline_content": [
          {
            "Text": "Characteristics",
            "AttrFlags": 4
          },
          {
            "Text": ". Defines the section characteristics. These values are found both in WINNT.H and in the Portable Executable Format specification located on this CD."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938436,
        "id": "6604d525-8f4a-4eda-a0fb-16f98bfdb948",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938436,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Value",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "Definition",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "0x00000020"
            ],
            [
              "Code section"
            ],
            [
              "0x00000040"
            ],
            [
              "Initialized data section"
            ],
            [
              "0x00000080"
            ],
            [
              "Uninitialized data section"
            ],
            [
              "0x04000000"
            ],
            [
              "Section cannot be cached"
            ],
            [
              "0x08000000"
            ],
            [
              "Section is not pageable"
            ],
            [
              "0x10000000"
            ],
            [
              "Section is shared"
            ],
            [
              "0x20000000"
            ],
            [
              "Executable section"
            ],
            [
              "0x40000000"
            ],
            [
              "Readable section"
            ],
            [
              "0x80000000"
            ],
            [
              "Writable section"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Value",
            "AttrFlags": 1
          },
          {
            "Text": "Definition",
            "AttrFlags": 1
          },
          {
            "Text": "0x00000020"
          },
          {
            "Text": "Code section"
          },
          {
            "Text": "0x00000040"
          },
          {
            "Text": "Initialized data section"
          },
          {
            "Text": "0x00000080"
          },
          {
            "Text": "Uninitialized data section"
          },
          {
            "Text": "0x04000000"
          },
          {
            "Text": "Section cannot be cached"
          },
          {
            "Text": "0x08000000"
          },
          {
            "Text": "Section is not pageable"
          },
          {
            "Text": "0x10000000"
          },
          {
            "Text": "Section is shared"
          },
          {
            "Text": "0x20000000"
          },
          {
            "Text": "Executable section"
          },
          {
            "Text": "0x40000000"
          },
          {
            "Text": "Readable section"
          },
          {
            "Text": "0x80000000"
          },
          {
            "Text": "Writable section"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938438,
        "id": "f11db5aa-ce54-4aee-89bd-e69401a2883c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938438,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Locating Data Directories"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Locating Data Directories"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938438,
        "id": "8ea01b16-77cb-40a5-9b6e-f20d28252681",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938438,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Data directories exist within the body of their corresponding data section. Typically, data directories are the first structure within the section body, but not out of necessity. For that reason, you need to retrieve information from both the section header and optional header to locate a specific data directory. To make this process easier, the following function was written to locate the data directory for any of the directories defined in WINNT.H:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Data directories exist within the body of their corresponding data section. Typically, data directories are the first structure within the section body, but not out of necessity. For that reason, you need to retrieve information from both the section header and optional header to locate a specific data directory. To make this process easier, the following function was written to locate the data directory for any of the directories defined in WINNT.H:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938438,
        "id": "911413b2-ebbd-46e3-a75a-b9a1c0561370",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938438,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "LPVOID  WINAPI ImageDirectoryOffset (\n        LPVOID    lpFile,\n        DWORD     dwIMAGE_DIRECTORY)\n{\n    PIMAGE_OPTIONAL_HEADER   poh;\n    PIMAGE_SECTION_HEADER    psh;\n    int                      nSections = NumOfSections (lpFile);\n    int                      i = 0;\n    LPVOID                   VAImageDir;\n\n    /* Must be 0 thru (NumberOfRvaAndSizes-1). */\n    if (dwIMAGE_DIRECTORY \u003e= poh-\u003eNumberOfRvaAndSizes)\n        return NULL;\n\n    /* Retrieve offsets to optional and section headers. */\n    poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);\n    psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile);\n\n    /* Locate image directory's relative virtual address. */\n    VAImageDir = (LPVOID)poh-\u003eDataDirectory\n                       [dwIMAGE_DIRECTORY].VirtualAddress;\n\n    /* Locate section containing image directory. */\n    while (i++\u003cnSections)\n        {\n        if (psh-\u003eVirtualAddress \u003c= (DWORD)VAImageDir \u0026\u0026\n            psh-\u003eVirtualAddress +\n                 psh-\u003eSizeOfRawData \u003e (DWORD)VAImageDir)\n            break;\n        psh++;\n        }\n\n    if (i \u003e nSections)\n        return NULL;\n\n    /* Return image import directory offset. */\n    return (LPVOID)(((int)lpFile +\n                     (int)VAImageDir. psh-\u003eVirtualAddress) +\n                    (int)psh-\u003ePointerToRawData);\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "LPVOID  WINAPI ImageDirectoryOffset (\n        LPVOID    lpFile,\n        DWORD     dwIMAGE_DIRECTORY)\n{\n    PIMAGE_OPTIONAL_HEADER   poh;\n    PIMAGE_SECTION_HEADER    psh;\n    int                      nSections = NumOfSections (lpFile);\n    int                      i = 0;\n    LPVOID                   VAImageDir;\n\n    /* Must be 0 thru (NumberOfRvaAndSizes-1). */\n    if (dwIMAGE_DIRECTORY \u003e= poh-\u003eNumberOfRvaAndSizes)\n        return NULL;\n\n    /* Retrieve offsets to optional and section headers. */\n    poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);\n    psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile);\n\n    /* Locate image directory's relative virtual address. */\n    VAImageDir = (LPVOID)poh-\u003eDataDirectory\n                       [dwIMAGE_DIRECTORY].VirtualAddress;\n\n    /* Locate section containing image directory. */\n    while (i++\u003cnSections)\n        {\n        if (psh-\u003eVirtualAddress \u003c= (DWORD)VAImageDir \u0026\u0026\n            psh-\u003eVirtualAddress +\n                 psh-\u003eSizeOfRawData \u003e (DWORD)VAImageDir)\n            break;\n        psh++;\n        }\n\n    if (i \u003e nSections)\n        return NULL;\n\n    /* Return image import directory offset. */\n    return (LPVOID)(((int)lpFile +\n                     (int)VAImageDir. psh-\u003eVirtualAddress) +\n                    (int)psh-\u003ePointerToRawData);\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938438,
        "id": "e025a574-bade-4e9d-a8d0-287ffccb0017",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938438,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The function begins by validating the requested data directory entry number. Then it retrieves pointers to the optional header and first section header. From the optional header, the function determines the data directory’s virtual address, and it uses this value to determine within which section body the data directory is located. Once the appropriate section body has been identified, the specific location of the data directory is found by translating the relative virtual address of the data directory to a specific address into the file."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The function begins by validating the requested data directory entry number. Then it retrieves pointers to the optional header and first section header. From the optional header, the function determines the data directory’s virtual address, and it uses this value to determine within which section body the data directory is located. Once the appropriate section body has been identified, the specific location of the data directory is found by translating the relative virtual address of the data directory to a specific address into the file."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938439,
        "id": "a475f23c-5ce0-4f59-bae9-bc69537d19a7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938439,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Predefined Sections"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Predefined Sections"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938440,
        "id": "cd8a7336-5bcf-4544-9115-312b05f19982",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938440,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "An application for Windows NT typically has the nine predefined sections named .text, .bss, .rdata, .data, .rsrc, .edata, .idata, .pdata, and .debug. Some applications do not need all of these sections, while others may define still more sections to suit their specific needs. This behavior is similar to code and data segments in MS-DOS and Windows version 3.1. In fact, the way an application defines a unique section is by using the standard compiler directives for naming code and data segments or by using the name segment compiler option "
            ],
            [
              "-NT",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "–exactly the same way in which applications defined unique code and data segments in Windows version 3.1. The following is a discussion of some of the more interesting sections common to typical Windows NT PE files."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "An application for Windows NT typically has the nine predefined sections named .text, .bss, .rdata, .data, .rsrc, .edata, .idata, .pdata, and .debug. Some applications do not need all of these sections, while others may define still more sections to suit their specific needs. This behavior is similar to code and data segments in MS-DOS and Windows version 3.1. In fact, the way an application defines a unique section is by using the standard compiler directives for naming code and data segments or by using the name segment compiler option "
          },
          {
            "Text": "-NT",
            "AttrFlags": 1
          },
          {
            "Text": "–exactly the same way in which applications defined unique code and data segments in Windows version 3.1. The following is a discussion of some of the more interesting sections common to typical Windows NT PE files."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938440,
        "id": "abdbe564-8ed9-4069-a75c-865c98f2b3ff",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938440,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Executable code section, .text"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Executable code section, .text"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938440,
        "id": "0c14091c-a6ed-4540-8e84-ff27b8844a2e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938440,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "One difference between Windows version 3.1 and Windows NT is that the default behavior combines all code segments (as they are referred to in Windows version 3.1) into a single section called “.text” in Windows NT. Since Windows NT uses a page-based virtual memory management system, there is no advantage to separating code into distinct code segments. Consequently, having one large code section is easier to manage for both the operating system and the application developer. The .text section also contains the entry point mentioned earlier. The IAT also lives in the .text section immediately before the module entry point. (The IAT’s presence in the .text section makes sense because the table is really a series of jump instructions, for which the specific location to jump to is the fixed-up address.) When Windows NT executable images are loaded into a process’s address space, the IAT is fixed up with the location of each imported function’s physical address. In order to find the IAT in the .text section, the loader simply locates the module entry point and relies on the fact that the IAT occurs immediately before the entry point. And since each entry is the same size, it is easy to walk backward in the table to find its beginning."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "One difference between Windows version 3.1 and Windows NT is that the default behavior combines all code segments (as they are referred to in Windows version 3.1) into a single section called “.text” in Windows NT. Since Windows NT uses a page-based virtual memory management system, there is no advantage to separating code into distinct code segments. Consequently, having one large code section is easier to manage for both the operating system and the application developer. The .text section also contains the entry point mentioned earlier. The IAT also lives in the .text section immediately before the module entry point. (The IAT’s presence in the .text section makes sense because the table is really a series of jump instructions, for which the specific location to jump to is the fixed-up address.) When Windows NT executable images are loaded into a process’s address space, the IAT is fixed up with the location of each imported function’s physical address. In order to find the IAT in the .text section, the loader simply locates the module entry point and relies on the fact that the IAT occurs immediately before the entry point. And since each entry is the same size, it is easy to walk backward in the table to find its beginning."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938440,
        "id": "c0bb88f8-acd1-4803-9b69-2b88ab90e0e7",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938440,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Data sections, .bss, .rdata, .data"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Data sections, .bss, .rdata, .data"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938441,
        "id": "9fcfc93e-1dae-4f07-8263-0c62b7b9c74c",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938441,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The .bss section represents uninitialized data for the application, including all variables declared as static within a function or source module. The .rdata section represents read-only data, such as literal strings, constants, and debug directory information. All other variables (except automatic variables, which appear on the stack) are stored in the .data section. Basically, these are application or module global variables."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The .bss section represents uninitialized data for the application, including all variables declared as static within a function or source module. The .rdata section represents read-only data, such as literal strings, constants, and debug directory information. All other variables (except automatic variables, which appear on the stack) are stored in the .data section. Basically, these are application or module global variables."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938441,
        "id": "11b06fb6-9642-4e68-ada1-fa0360e53d95",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938441,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Resources section, .rsrc"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Resources section, .rsrc"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938441,
        "id": "485e3a97-f021-4b9b-bd1b-a3c5a4b59f8e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938441,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The .rsrc section contains resource information for a module. It begins with a resource directory structure like most other sections, but this section’s data is further structured into a resource tree. The "
            ],
            [
              "IMAGE_RESOURCE_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", shown below, forms the root and nodes of the tree. "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The .rsrc section contains resource information for a module. It begins with a resource directory structure like most other sections, but this section’s data is further structured into a resource tree. The "
          },
          {
            "Text": "IMAGE_RESOURCE_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": ", shown below, forms the root and nodes of the tree. "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938441,
        "id": "5c3dc8e1-881c-4905-8213-6e93bc52f139",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938441,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_RESOURCE_DIRECTORY {\n    ULONG   Characteristics;\n    ULONG   TimeDateStamp;\n    USHORT  MajorVersion;\n    USHORT  MinorVersion;\n    USHORT  NumberOfNamedEntries;\n    USHORT  NumberOfIdEntries;\n} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_RESOURCE_DIRECTORY {\n    ULONG   Characteristics;\n    ULONG   TimeDateStamp;\n    USHORT  MajorVersion;\n    USHORT  MinorVersion;\n    USHORT  NumberOfNamedEntries;\n    USHORT  NumberOfIdEntries;\n} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938442,
        "id": "1af25c0c-a60f-4982-9bf2-1b6377ea7e8f",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938442,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Looking at the directory structure, you won’t find any pointer to the next nodes. Instead, there are two fields, "
            ],
            [
              "NumberOfNamedEntries",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "NumberOfIdEntries",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", used to indicate how many entries are attached to the directory. By "
            ],
            [
              "attached",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", I mean the directory entries follow immediately after the directory in the section data. The named entries appear first in ascending alphabetical order, followed by the ID entries in ascending numerical order. A directory entry consists of two fields, as described in the following "
            ],
            [
              "IMAGE_RESOURCE_DIRECTORY_ENTRY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Looking at the directory structure, you won’t find any pointer to the next nodes. Instead, there are two fields, "
          },
          {
            "Text": "NumberOfNamedEntries",
            "AttrFlags": 4
          },
          {
            "Text": " and "
          },
          {
            "Text": "NumberOfIdEntries",
            "AttrFlags": 4
          },
          {
            "Text": ", used to indicate how many entries are attached to the directory. By "
          },
          {
            "Text": "attached",
            "AttrFlags": 4
          },
          {
            "Text": ", I mean the directory entries follow immediately after the directory in the section data. The named entries appear first in ascending alphabetical order, followed by the ID entries in ascending numerical order. A directory entry consists of two fields, as described in the following "
          },
          {
            "Text": "IMAGE_RESOURCE_DIRECTORY_ENTRY",
            "AttrFlags": 1
          },
          {
            "Text": " structure: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938442,
        "id": "303e5758-e30b-4c91-a5f5-0f5b9c0ee7b9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938442,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n    ULONG   Name;\n    ULONG   OffsetToData;\n} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n    ULONG   Name;\n    ULONG   OffsetToData;\n} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938442,
        "id": "029f189b-bf32-4ce7-82a4-ed9ac1503dec",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938442,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The two fields are used for different things depending on the level of the tree. The "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is used to identify either a type of resource, a resource name, or a resource’s language ID. The "
            ],
            [
              "OffsetToData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is always used to point to a sibling in the tree, either a directory node or a leaf node. Leaf nodes are the lowest node in the resource tree. They define the size and location of the actual resource data. Each leaf node is represented using the following "
            ],
            [
              "IMAGE_RESOURCE_DATA_ENTRY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The two fields are used for different things depending on the level of the tree. The "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field is used to identify either a type of resource, a resource name, or a resource’s language ID. The "
          },
          {
            "Text": "OffsetToData",
            "AttrFlags": 4
          },
          {
            "Text": " field is always used to point to a sibling in the tree, either a directory node or a leaf node. Leaf nodes are the lowest node in the resource tree. They define the size and location of the actual resource data. Each leaf node is represented using the following "
          },
          {
            "Text": "IMAGE_RESOURCE_DATA_ENTRY",
            "AttrFlags": 1
          },
          {
            "Text": " structure: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938442,
        "id": "b9a5164c-f689-4de1-bc3a-c31168cef26e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938442,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_RESOURCE_DATA_ENTRY {\n    ULONG   OffsetToData;\n    ULONG   Size;\n    ULONG   CodePage;\n    ULONG   Reserved;\n} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_RESOURCE_DATA_ENTRY {\n    ULONG   OffsetToData;\n    ULONG   Size;\n    ULONG   CodePage;\n    ULONG   Reserved;\n} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938443,
        "id": "3b4ca90c-eceb-4f56-afe5-e5d7b094128b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938443,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The two fields "
            ],
            [
              "OffsetToData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "Size",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " indicate the location and size of the actual resource data. Since this information is used primarily by functions once the application has been loaded, it makes more sense to make the "
            ],
            [
              "OffsetToData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field a relative virtual address. This is precisely the case. Interestingly enough, all other offsets, such as pointers from directory entries to other directories, are offsets relative to the location of the root node. To make all of this a little clearer, consider Figure 2. "
            ],
            [
              "Figure 2. A simple resource tree structure",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " Figure 2 depicts a very simple resource tree containing only two resource objects, a menu, and a string table. Further, the menu and string table have only one item each. Yet, you can see how complicated the resource tree becomes–even with as few resources as this. At the root of the tree, the first directory has one entry for each type of resource the file contains, no matter how many of each type there are. In Figure 2, there are two entries identified by the root, one for the menu and one for the string table. If there had been one or more dialog resources included in the file, the root node would have had one more entry and, consequently, another branch for the dialog resources. The basic resource types are identified in the file WINUSER.H and are listed below: "
            ],
            [
              "WINUSER.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The two fields "
          },
          {
            "Text": "OffsetToData",
            "AttrFlags": 4
          },
          {
            "Text": " and "
          },
          {
            "Text": "Size",
            "AttrFlags": 4
          },
          {
            "Text": " indicate the location and size of the actual resource data. Since this information is used primarily by functions once the application has been loaded, it makes more sense to make the "
          },
          {
            "Text": "OffsetToData",
            "AttrFlags": 4
          },
          {
            "Text": " field a relative virtual address. This is precisely the case. Interestingly enough, all other offsets, such as pointers from directory entries to other directories, are offsets relative to the location of the root node. To make all of this a little clearer, consider Figure 2. "
          },
          {
            "Text": "Figure 2. A simple resource tree structure",
            "AttrFlags": 1
          },
          {
            "Text": " Figure 2 depicts a very simple resource tree containing only two resource objects, a menu, and a string table. Further, the menu and string table have only one item each. Yet, you can see how complicated the resource tree becomes–even with as few resources as this. At the root of the tree, the first directory has one entry for each type of resource the file contains, no matter how many of each type there are. In Figure 2, there are two entries identified by the root, one for the menu and one for the string table. If there had been one or more dialog resources included in the file, the root node would have had one more entry and, consequently, another branch for the dialog resources. The basic resource types are identified in the file WINUSER.H and are listed below: "
          },
          {
            "Text": "WINUSER.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938443,
        "id": "ff0a358b-0f5f-4a8d-84cc-6d5133ae1391",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938443,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "/*\n * Predefined Resource Types\n */\n#define RT_CURSOR           MAKEINTRESOURCE(1)\n#define RT_BITMAP           MAKEINTRESOURCE(2)\n#define RT_ICON             MAKEINTRESOURCE(3)\n#define RT_MENU             MAKEINTRESOURCE(4)\n#define RT_DIALOG           MAKEINTRESOURCE(5)\n#define RT_STRING           MAKEINTRESOURCE(6)\n#define RT_FONTDIR          MAKEINTRESOURCE(7)\n#define RT_FONT             MAKEINTRESOURCE(8)\n#define RT_ACCELERATOR      MAKEINTRESOURCE(9)\n#define RT_RCDATA           MAKEINTRESOURCE(10)\n#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "/*\n * Predefined Resource Types\n */\n#define RT_CURSOR           MAKEINTRESOURCE(1)\n#define RT_BITMAP           MAKEINTRESOURCE(2)\n#define RT_ICON             MAKEINTRESOURCE(3)\n#define RT_MENU             MAKEINTRESOURCE(4)\n#define RT_DIALOG           MAKEINTRESOURCE(5)\n#define RT_STRING           MAKEINTRESOURCE(6)\n#define RT_FONTDIR          MAKEINTRESOURCE(7)\n#define RT_FONT             MAKEINTRESOURCE(8)\n#define RT_ACCELERATOR      MAKEINTRESOURCE(9)\n#define RT_RCDATA           MAKEINTRESOURCE(10)\n#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938443,
        "id": "cbdec4d0-bcf5-4194-8e60-db3cc7b6db26",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938443,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "At the top level of the tree, the MAKEINTRESOURCE values listed above are placed in the "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field of each type entry, identifying the different resources by type. Each of the entries in the root directory points to a sibling node in the second level of the tree. These nodes are directories, too, each having their own entries. At this level, the directories are used to identify the name of each resource within a given type. If you had multiple menus defined in your application, there would be an entry for each one here at the second level of the tree. As you are probably already aware, resources can be identified by name or by integer. They are distinguished in this level of the tree via the "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field in the directory structure. If the most significant bit of the "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is set, the other 31 bits are used as an offset to an "
            ],
            [
              "IMAGE_RESOURCE_DIR_STRING_U",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure. "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "At the top level of the tree, the MAKEINTRESOURCE values listed above are placed in the "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field of each type entry, identifying the different resources by type. Each of the entries in the root directory points to a sibling node in the second level of the tree. These nodes are directories, too, each having their own entries. At this level, the directories are used to identify the name of each resource within a given type. If you had multiple menus defined in your application, there would be an entry for each one here at the second level of the tree. As you are probably already aware, resources can be identified by name or by integer. They are distinguished in this level of the tree via the "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field in the directory structure. If the most significant bit of the "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field is set, the other 31 bits are used as an offset to an "
          },
          {
            "Text": "IMAGE_RESOURCE_DIR_STRING_U",
            "AttrFlags": 1
          },
          {
            "Text": " structure. "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938443,
        "id": "0ffc42d9-811b-446b-b5ea-82e0b45a6793",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938443,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_RESOURCE_DIR_STRING_U {\n    USHORT  Length;\n    WCHAR   NameString[ 1 ];\n} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_RESOURCE_DIR_STRING_U {\n    USHORT  Length;\n    WCHAR   NameString[ 1 ];\n} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938444,
        "id": "3beb8b30-dd1e-4e52-866c-d5454a26de61",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938444,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This structure is simply a 2-byte "
            ],
            [
              "Length",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field followed by "
            ],
            [
              "Length",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " UNICODE characters. On the other hand, if the most significant bit of the "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is clear, the lower 31 bits are used to represent the integer ID of the resource. Figure 2 shows the menu resource as a named resource and the string table as an ID resource. If there were two menu resources, one identified by name and one by resource, they would both have entries immediately after the menu resource directory. The named resource entry would appear first, followed by the integer-identified resource. The directory fields "
            ],
            [
              "NumberOfNamedEntries",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "NumberOfIdEntries",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " would each contain the value 1, indicating the presence of one entry. Below level two, the resource tree does not branch out any further. Level one branches into directories representing each type of resource, and level two branches into directories representing each resource by identifier. Level three maps a one-to-one correspondence between the individually identified resources and their respective language IDs. To indicate the language ID of a resource, the "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field of the directory entry structure is used to indicate both the primary language and sublanguage ID for the resource. For the value 0x0409, 0x09 represents the primary language as LANG_ENGLISH, and 0x04 is defined as SUBLANG_ENGLISH_CAN for the sublanguage. The entire set of language IDs is defined in the file WINNT.H. Since the language ID node is the last directory node in the tree, the "
            ],
            [
              "OffsetToData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field in the entry structure is an offset to a leaf node–the "
            ],
            [
              "IMAGE_RESOURCE_DATA_ENTRY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure mentioned earlier. Referring back to Figure 2, you can see one data entry node for each language directory entry. This node simply indicates the size of the resource data and the relative virtual address where the resource data is located. One advantage to having so much structure to the resource data section, .rsrc, is that you can glean a great deal of information from the section without accessing the resources themselves. For example, you can find out how many there are of each type of resource, what resources–if any–use a particular language ID, whether a particular resource exists or not, and the size of individual types of resources. To demonstrate how to make use of this information, the following function shows how to determine the different types of resources a file includes:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This structure is simply a 2-byte "
          },
          {
            "Text": "Length",
            "AttrFlags": 4
          },
          {
            "Text": " field followed by "
          },
          {
            "Text": "Length",
            "AttrFlags": 4
          },
          {
            "Text": " UNICODE characters. On the other hand, if the most significant bit of the "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field is clear, the lower 31 bits are used to represent the integer ID of the resource. Figure 2 shows the menu resource as a named resource and the string table as an ID resource. If there were two menu resources, one identified by name and one by resource, they would both have entries immediately after the menu resource directory. The named resource entry would appear first, followed by the integer-identified resource. The directory fields "
          },
          {
            "Text": "NumberOfNamedEntries",
            "AttrFlags": 4
          },
          {
            "Text": " and "
          },
          {
            "Text": "NumberOfIdEntries",
            "AttrFlags": 4
          },
          {
            "Text": " would each contain the value 1, indicating the presence of one entry. Below level two, the resource tree does not branch out any further. Level one branches into directories representing each type of resource, and level two branches into directories representing each resource by identifier. Level three maps a one-to-one correspondence between the individually identified resources and their respective language IDs. To indicate the language ID of a resource, the "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field of the directory entry structure is used to indicate both the primary language and sublanguage ID for the resource. For the value 0x0409, 0x09 represents the primary language as LANG_ENGLISH, and 0x04 is defined as SUBLANG_ENGLISH_CAN for the sublanguage. The entire set of language IDs is defined in the file WINNT.H. Since the language ID node is the last directory node in the tree, the "
          },
          {
            "Text": "OffsetToData",
            "AttrFlags": 4
          },
          {
            "Text": " field in the entry structure is an offset to a leaf node–the "
          },
          {
            "Text": "IMAGE_RESOURCE_DATA_ENTRY",
            "AttrFlags": 1
          },
          {
            "Text": " structure mentioned earlier. Referring back to Figure 2, you can see one data entry node for each language directory entry. This node simply indicates the size of the resource data and the relative virtual address where the resource data is located. One advantage to having so much structure to the resource data section, .rsrc, is that you can glean a great deal of information from the section without accessing the resources themselves. For example, you can find out how many there are of each type of resource, what resources–if any–use a particular language ID, whether a particular resource exists or not, and the size of individual types of resources. To demonstrate how to make use of this information, the following function shows how to determine the different types of resources a file includes:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938444,
        "id": "0b499391-2bd2-4f9a-a2cd-342c6a006b4b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938444,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int     WINAPI GetListOfResourceTypes (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszResTypes)\n{\n    PIMAGE_RESOURCE_DIRECTORY          prdRoot;\n    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;\n    char                               *pMem;\n    int                                nCnt, i;\n\n\n    /* Get root directory of resource tree. */\n    if ((prdRoot = PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset\n           (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)\n        return 0;\n\n    /* Allocate enough space from heap to cover all types. */\n    nCnt = prdRoot-\u003eNumberOfIdEntries * (MAXRESOURCENAME + 1);\n    *pszResTypes = (char *)HeapAlloc (hHeap,\n                                      HEAP_ZERO_MEMORY,\n                                      nCnt);\n    if ((pMem = *pszResTypes) == NULL)\n        return 0;\n\n    /* Set pointer to first resource type entry. */\n    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)prdRoot +\n               sizeof (IMAGE_RESOURCE_DIRECTORY));\n\n    /* Loop through all resource directory entry types. */\n    for (i=0; i\u003cprdRoot-\u003eNumberOfIdEntries; i++)\n        {\n        if (LoadString (hDll, prde-\u003eName, pMem, MAXRESOURCENAME))\n            pMem += strlen (pMem) + 1;\n\n        prde++;\n        }\n\n    return nCnt;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int     WINAPI GetListOfResourceTypes (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszResTypes)\n{\n    PIMAGE_RESOURCE_DIRECTORY          prdRoot;\n    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;\n    char                               *pMem;\n    int                                nCnt, i;\n\n\n    /* Get root directory of resource tree. */\n    if ((prdRoot = PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset\n           (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)\n        return 0;\n\n    /* Allocate enough space from heap to cover all types. */\n    nCnt = prdRoot-\u003eNumberOfIdEntries * (MAXRESOURCENAME + 1);\n    *pszResTypes = (char *)HeapAlloc (hHeap,\n                                      HEAP_ZERO_MEMORY,\n                                      nCnt);\n    if ((pMem = *pszResTypes) == NULL)\n        return 0;\n\n    /* Set pointer to first resource type entry. */\n    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)prdRoot +\n               sizeof (IMAGE_RESOURCE_DIRECTORY));\n\n    /* Loop through all resource directory entry types. */\n    for (i=0; i\u003cprdRoot-\u003eNumberOfIdEntries; i++)\n        {\n        if (LoadString (hDll, prde-\u003eName, pMem, MAXRESOURCENAME))\n            pMem += strlen (pMem) + 1;\n\n        prde++;\n        }\n\n    return nCnt;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938444,
        "id": "8332a297-3fb6-4e65-997f-eb475ee5c5aa",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938444,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This function returns a list of resource type names in the string identified by "
            ],
            [
              "pszResTypes",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ". Notice that, at the heart of this function, "
            ],
            [
              "LoadString",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " is called using the "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field of each resource type directory entry as the string ID.of resource type strings whose IDs are defined the same as the type specifiers in the directory entries.It would be rather easy to expand on these functions or write new functions that extracted other information from this section."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This function returns a list of resource type names in the string identified by "
          },
          {
            "Text": "pszResTypes",
            "AttrFlags": 4
          },
          {
            "Text": ". Notice that, at the heart of this function, "
          },
          {
            "Text": "LoadString",
            "AttrFlags": 1
          },
          {
            "Text": " is called using the "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field of each resource type directory entry as the string ID.of resource type strings whose IDs are defined the same as the type specifiers in the directory entries.It would be rather easy to expand on these functions or write new functions that extracted other information from this section."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938445,
        "id": "48df2dc0-5c18-4af2-9d63-fa57e985eb6d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938445,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Export data section, .edata"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Export data section, .edata"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938445,
        "id": "78d7062b-6676-4c4c-b7af-1e9e0659204a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938445,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The .edata section contains export data for an application or DLL. When present, this section contains an export directory for getting to the export information. "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The .edata section contains export data for an application or DLL. When present, this section contains an export directory for getting to the export information. "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938445,
        "id": "bab5ffc8-28d5-4e1b-8edf-58056b730a7e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938445,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_EXPORT_DIRECTORY {\n    ULONG   Characteristics;\n    ULONG   TimeDateStamp;\n    USHORT  MajorVersion;\n    USHORT  MinorVersion;\n    ULONG   Name;\n    ULONG   Base;\n    ULONG   NumberOfFunctions;\n    ULONG   NumberOfNames;\n    PULONG  *AddressOfFunctions;\n    PULONG  *AddressOfNames;\n    PUSHORT *AddressOfNameOrdinals;\n} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_EXPORT_DIRECTORY {\n    ULONG   Characteristics;\n    ULONG   TimeDateStamp;\n    USHORT  MajorVersion;\n    USHORT  MinorVersion;\n    ULONG   Name;\n    ULONG   Base;\n    ULONG   NumberOfFunctions;\n    ULONG   NumberOfNames;\n    PULONG  *AddressOfFunctions;\n    PULONG  *AddressOfNames;\n    PUSHORT *AddressOfNameOrdinals;\n} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938445,
        "id": "00375ce4-bfd6-4e87-a615-ac825b05681e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938445,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The "
            ],
            [
              "Name",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field in the export directory identifies the name of the executable module. "
            ],
            [
              "NumberOfFunctions",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " and "
            ],
            [
              "NumberOfNames",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " fields indicate how many functions and function names are being exported from the module. The "
            ],
            [
              "AddressOfFunctions",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is an offset to a list of exported function entry points. The "
            ],
            [
              "AddressOfNames",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field is the address of an offset to the beginning of a null-separated list of exported function names. "
            ],
            [
              "AddressOfNameOrdinals",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " is an offset to a list of ordinal values (each 2 bytes long) for the same exported functions. The three "
            ],
            [
              "AddressOf…",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " fields are relative virtual addresses into the address space of a process once the module has been loaded. Once the module is loaded, the relative virtual address should be added to the module base address to get the exact location in the address space of the process. Before the file is loaded, however, the address can be determined by subtracting the section header virtual address ("
            ],
            [
              "VirtualAddress",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ") from the given field address, adding the section body offset ("
            ],
            [
              "PointerToRawData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ") to the result, and then using this value as an offset into the image file. The following example illustrates this technique:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The "
          },
          {
            "Text": "Name",
            "AttrFlags": 4
          },
          {
            "Text": " field in the export directory identifies the name of the executable module. "
          },
          {
            "Text": "NumberOfFunctions",
            "AttrFlags": 4
          },
          {
            "Text": " and "
          },
          {
            "Text": "NumberOfNames",
            "AttrFlags": 4
          },
          {
            "Text": " fields indicate how many functions and function names are being exported from the module. The "
          },
          {
            "Text": "AddressOfFunctions",
            "AttrFlags": 4
          },
          {
            "Text": " field is an offset to a list of exported function entry points. The "
          },
          {
            "Text": "AddressOfNames",
            "AttrFlags": 4
          },
          {
            "Text": " field is the address of an offset to the beginning of a null-separated list of exported function names. "
          },
          {
            "Text": "AddressOfNameOrdinals",
            "AttrFlags": 4
          },
          {
            "Text": " is an offset to a list of ordinal values (each 2 bytes long) for the same exported functions. The three "
          },
          {
            "Text": "AddressOf…",
            "AttrFlags": 4
          },
          {
            "Text": " fields are relative virtual addresses into the address space of a process once the module has been loaded. Once the module is loaded, the relative virtual address should be added to the module base address to get the exact location in the address space of the process. Before the file is loaded, however, the address can be determined by subtracting the section header virtual address ("
          },
          {
            "Text": "VirtualAddress",
            "AttrFlags": 4
          },
          {
            "Text": ") from the given field address, adding the section body offset ("
          },
          {
            "Text": "PointerToRawData",
            "AttrFlags": 4
          },
          {
            "Text": ") to the result, and then using this value as an offset into the image file. The following example illustrates this technique:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938446,
        "id": "a8bcdcaf-fd7a-4e48-b8e3-4fc2dc1cda2a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938446,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int  WINAPI GetExportFunctionNames (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszFunctions)\n{\n    IMAGE_SECTION_HEADER       sh;\n    PIMAGE_EXPORT_DIRECTORY    ped;\n    char                       *pNames, *pCnt;\n    int                        i, nCnt;\n\n    /* Get section header and pointer to data directory\n       for .edata section. */\n    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset\n            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)\n        return 0;\n    GetSectionHdrByName (lpFile, \u0026sh, \".edata\");\n\n    /* Determine the offset of the export function names. */\n    pNames = (char *)(*(int *)((int)ped-\u003eAddressOfNames -\n                               (int)sh.VirtualAddress   +\n                               (int)sh.PointerToRawData +\n                               (int)lpFile)    -\n                      (int)sh.VirtualAddress   +\n                      (int)sh.PointerToRawData +\n                      (int)lpFile);\n\n    /* Figure out how much memory to allocate for all strings. */\n    pCnt = pNames;\n    for (i=0; i\u003c(int)ped-\u003eNumberOfNames; i++)\n        while (*pCnt++);\n    nCnt = (int)(pCnt. pNames);\n\n    /* Allocate memory off heap for function names. */\n    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);\n\n    /* Copy all strings to buffer. */\n    CopyMemory ((LPVOID)*pszFunctions, (LPVOID)pNames, nCnt);\n\n    return nCnt;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int  WINAPI GetExportFunctionNames (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszFunctions)\n{\n    IMAGE_SECTION_HEADER       sh;\n    PIMAGE_EXPORT_DIRECTORY    ped;\n    char                       *pNames, *pCnt;\n    int                        i, nCnt;\n\n    /* Get section header and pointer to data directory\n       for .edata section. */\n    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset\n            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)\n        return 0;\n    GetSectionHdrByName (lpFile, \u0026sh, \".edata\");\n\n    /* Determine the offset of the export function names. */\n    pNames = (char *)(*(int *)((int)ped-\u003eAddressOfNames -\n                               (int)sh.VirtualAddress   +\n                               (int)sh.PointerToRawData +\n                               (int)lpFile)    -\n                      (int)sh.VirtualAddress   +\n                      (int)sh.PointerToRawData +\n                      (int)lpFile);\n\n    /* Figure out how much memory to allocate for all strings. */\n    pCnt = pNames;\n    for (i=0; i\u003c(int)ped-\u003eNumberOfNames; i++)\n        while (*pCnt++);\n    nCnt = (int)(pCnt. pNames);\n\n    /* Allocate memory off heap for function names. */\n    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);\n\n    /* Copy all strings to buffer. */\n    CopyMemory ((LPVOID)*pszFunctions, (LPVOID)pNames, nCnt);\n\n    return nCnt;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938446,
        "id": "658e4471-475d-4733-bf32-c40121fb036d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938446,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Notice that in this function the variable "
            ],
            [
              "pNames",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " is assigned by determining first the address of the offset and then the actual offset location. Both the address of the offset and the offset itself are relative virtual addresses and must be translated before being used, as the function demonstrates. You could write a similar function to determine the ordinal values or entry points of the functions."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Notice that in this function the variable "
          },
          {
            "Text": "pNames",
            "AttrFlags": 4
          },
          {
            "Text": " is assigned by determining first the address of the offset and then the actual offset location. Both the address of the offset and the offset itself are relative virtual addresses and must be translated before being used, as the function demonstrates. You could write a similar function to determine the ordinal values or entry points of the functions."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938447,
        "id": "35cb884e-b04b-473e-a777-36739d8937cf",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938447,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Import data section, .idata"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Import data section, .idata"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938447,
        "id": "e275402e-12dc-4530-8843-c698dbdccaa6",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938447,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The .idata section is import data, including the import directory and import address name table. Although an IMAGE_DIRECTORY_ENTRY_IMPORT directory is defined, no corresponding import directory structure is included in the file WINNT.H. Instead, there are several other structures called IMAGE_IMPORT_BY_NAME, IMAGE_THUNK_DATA, and IMAGE_IMPORT_DESCRIPTOR. Personally, I couldn’t make heads or tails of how these structures are supposed to correlate to the .idata section, so I spent several hours deciphering the .idata section body and came up with a much simpler structure. I named this structure "
            ],
            [
              "IMAGE_IMPORT_MODULE_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              "."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The .idata section is import data, including the import directory and import address name table. Although an IMAGE_DIRECTORY_ENTRY_IMPORT directory is defined, no corresponding import directory structure is included in the file WINNT.H. Instead, there are several other structures called IMAGE_IMPORT_BY_NAME, IMAGE_THUNK_DATA, and IMAGE_IMPORT_DESCRIPTOR. Personally, I couldn’t make heads or tails of how these structures are supposed to correlate to the .idata section, so I spent several hours deciphering the .idata section body and came up with a much simpler structure. I named this structure "
          },
          {
            "Text": "IMAGE_IMPORT_MODULE_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": "."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938448,
        "id": "bc7b7d16-73e6-4f1c-b546-a31dfb96de8e",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938448,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct tagImportDirectory\n    {\n    DWORD    dwRVAFunctionNameList;\n    DWORD    dwUseless1;\n    DWORD    dwUseless2;\n    DWORD    dwRVAModuleName;\n    DWORD    dwRVAFunctionAddressList;\n    }IMAGE_IMPORT_MODULE_DIRECTORY,\n     * PIMAGE_IMPORT_MODULE_DIRECTORY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct tagImportDirectory\n    {\n    DWORD    dwRVAFunctionNameList;\n    DWORD    dwUseless1;\n    DWORD    dwUseless2;\n    DWORD    dwRVAModuleName;\n    DWORD    dwRVAFunctionAddressList;\n    }IMAGE_IMPORT_MODULE_DIRECTORY,\n     * PIMAGE_IMPORT_MODULE_DIRECTORY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938448,
        "id": "07929c62-2a4f-46d8-b1f5-d0873f77251d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938448,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Unlike the data directories of other sections, this one repeats one after another for each imported module in the file. Think of it as an entry in a list of module data directories, rather than a data directory to the entire section of data. Each entry is a directory to the import information for a specific module. One of the fields in the "
            ],
            [
              "IMAGE_IMPORT_MODULE_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure is "
            ],
            [
              "dwRVAModuleName",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", a relative virtual address pointing to the name of the module. There are also two "
            ],
            [
              "dwUseless",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " parameters in the structure that serve as padding to keep the structure aligned properly within the section. The PE file format specification mentions something about import flags, a time/date stamp, and major/minor versions, but these two fields remained empty throughout my experimentation, so I still consider them useless. Based on the definition of this structure, you can retrieve the names of modules and all functions in each module that are imported by an executable file. The following function demonstrates how to retrieve all the module names imported by a particular PE file:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Unlike the data directories of other sections, this one repeats one after another for each imported module in the file. Think of it as an entry in a list of module data directories, rather than a data directory to the entire section of data. Each entry is a directory to the import information for a specific module. One of the fields in the "
          },
          {
            "Text": "IMAGE_IMPORT_MODULE_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": " structure is "
          },
          {
            "Text": "dwRVAModuleName",
            "AttrFlags": 4
          },
          {
            "Text": ", a relative virtual address pointing to the name of the module. There are also two "
          },
          {
            "Text": "dwUseless",
            "AttrFlags": 4
          },
          {
            "Text": " parameters in the structure that serve as padding to keep the structure aligned properly within the section. The PE file format specification mentions something about import flags, a time/date stamp, and major/minor versions, but these two fields remained empty throughout my experimentation, so I still consider them useless. Based on the definition of this structure, you can retrieve the names of modules and all functions in each module that are imported by an executable file. The following function demonstrates how to retrieve all the module names imported by a particular PE file:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938448,
        "id": "9f73fa23-7096-4c21-a483-84303dc57b9b",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938448,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int  WINAPI GetImportModuleNames (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszModules)\n{\n    PIMAGE_IMPORT_MODULE_DIRECTORY  pid;\n    IMAGE_SECTION_HEADER            idsh;\n    BYTE                            *pData;\n    int                             nCnt = 0, nSize = 0, i;\n    char                            *pModule[1024];\n    char                            *psz;\n\n    pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)ImageDirectoryOffset\n             (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);\n    pData = (BYTE *)pid;\n\n    /* Locate section header for \".idata\" section. */\n    if (!GetSectionHdrByName (lpFile, \u0026idsh, \".idata\"))\n        return 0;\n\n    /* Extract all import modules. */\n    while (pid-\u003edwRVAModuleName)\n        {\n        /* Allocate buffer for absolute string offsets. */\n        pModule[nCnt] = (char *)(pData +\n               (pid-\u003edwRVAModuleName-idsh.VirtualAddress));\n        nSize += strlen (pModule[nCnt]) + 1;\n\n        /* Increment to the next import directory entry. */\n        pid++;\n        nCnt++;\n        }\n\n    /* Copy all strings to one chunk of heap memory. */\n    *pszModules = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize);\n    psz = *pszModules;\n    for (i=0; i\u003cnCnt; i++)\n        {\n        strcpy (psz, pModule[i]);\n        psz += strlen (psz) + 1;\n        }\n\n    return nCnt;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int  WINAPI GetImportModuleNames (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszModules)\n{\n    PIMAGE_IMPORT_MODULE_DIRECTORY  pid;\n    IMAGE_SECTION_HEADER            idsh;\n    BYTE                            *pData;\n    int                             nCnt = 0, nSize = 0, i;\n    char                            *pModule[1024];\n    char                            *psz;\n\n    pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)ImageDirectoryOffset\n             (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);\n    pData = (BYTE *)pid;\n\n    /* Locate section header for \".idata\" section. */\n    if (!GetSectionHdrByName (lpFile, \u0026idsh, \".idata\"))\n        return 0;\n\n    /* Extract all import modules. */\n    while (pid-\u003edwRVAModuleName)\n        {\n        /* Allocate buffer for absolute string offsets. */\n        pModule[nCnt] = (char *)(pData +\n               (pid-\u003edwRVAModuleName-idsh.VirtualAddress));\n        nSize += strlen (pModule[nCnt]) + 1;\n\n        /* Increment to the next import directory entry. */\n        pid++;\n        nCnt++;\n        }\n\n    /* Copy all strings to one chunk of heap memory. */\n    *pszModules = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize);\n    psz = *pszModules;\n    for (i=0; i\u003cnCnt; i++)\n        {\n        strcpy (psz, pModule[i]);\n        psz += strlen (psz) + 1;\n        }\n\n    return nCnt;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938448,
        "id": "1beaf7a6-f7f3-4878-a5fc-5e0fd69ee7bc",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938448,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The function is pretty straightforward. However, one thing is worth pointing out–notice the while loop. This loop is terminated when "
            ],
            [
              "pid-\u003edwRVAModuleName",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " is 0. Implied here is that at the end of the list of "
            ],
            [
              "IMAGE_IMPORT_MODULE_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structures is a null structure that has a value of 0 for at least the "
            ],
            [
              "dwRVAModuleName",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field. This is the behavior I observed in my experimentation with the file and later confirmed in the PE file format specification. The first field in the structure, "
            ],
            [
              "dwRVAFunctionNameList",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", is a relative virtual address to a list of relative virtual addresses that each point to the function names within the file. As shown in the following data, the module and function names of all imported modules are listed in the .idata section data:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The function is pretty straightforward. However, one thing is worth pointing out–notice the while loop. This loop is terminated when "
          },
          {
            "Text": "pid-\u003edwRVAModuleName",
            "AttrFlags": 4
          },
          {
            "Text": " is 0. Implied here is that at the end of the list of "
          },
          {
            "Text": "IMAGE_IMPORT_MODULE_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": " structures is a null structure that has a value of 0 for at least the "
          },
          {
            "Text": "dwRVAModuleName",
            "AttrFlags": 4
          },
          {
            "Text": " field. This is the behavior I observed in my experimentation with the file and later confirmed in the PE file format specification. The first field in the structure, "
          },
          {
            "Text": "dwRVAFunctionNameList",
            "AttrFlags": 4
          },
          {
            "Text": ", is a relative virtual address to a list of relative virtual addresses that each point to the function names within the file. As shown in the following data, the module and function names of all imported modules are listed in the .idata section data:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938448,
        "id": "a5d8aea0-fc47-4b1a-bf06-3cbf9c9fce76",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938448,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "E6A7 0000 F6A7 0000  08A8 0000 1AA8 0000  ................\n28A8 0000 3CA8 0000  4CA8 0000 0000 0000  (...\u003c...L.......\n0000 4765 744F 7065  6E46 696C 654E 616D  ..GetOpenFileNam\n6541 0000 636F 6D64  6C67 3332 2E64 6C6C  eA..comdlg32.dll\n0000 2500 4372 6561  7465 466F 6E74 496E  ..%.CreateFontIn\n6469 7265 6374 4100  4744 4933 322E 646C  directA.GDI32.dl\n6C00 A000 4765 7444  6576 6963 6543 6170  l...GetDeviceCap\n7300 C600 4765 7453  746F 636B 4F62 6A65  s...GetStockObje\n6374 0000 D500 4765  7454 6578 744D 6574  ct....GetTextMet\n7269 6373 4100 1001  5365 6C65 6374 4F62  ricsA...SelectOb\n6A65 6374 0000 1601  5365 7442 6B43 6F6C  ject....SetBkCol\n6F72 0000 3501 5365  7454 6578 7443 6F6C  or..5.SetTextCol\n6F72 0000 4501 5465  7874 4F75 7441 0000  or..E.TextOutA.."
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "E6A7 0000 F6A7 0000  08A8 0000 1AA8 0000  ................\n28A8 0000 3CA8 0000  4CA8 0000 0000 0000  (...\u003c...L.......\n0000 4765 744F 7065  6E46 696C 654E 616D  ..GetOpenFileNam\n6541 0000 636F 6D64  6C67 3332 2E64 6C6C  eA..comdlg32.dll\n0000 2500 4372 6561  7465 466F 6E74 496E  ..%.CreateFontIn\n6469 7265 6374 4100  4744 4933 322E 646C  directA.GDI32.dl\n6C00 A000 4765 7444  6576 6963 6543 6170  l...GetDeviceCap\n7300 C600 4765 7453  746F 636B 4F62 6A65  s...GetStockObje\n6374 0000 D500 4765  7454 6578 744D 6574  ct....GetTextMet\n7269 6373 4100 1001  5365 6C65 6374 4F62  ricsA...SelectOb\n6A65 6374 0000 1601  5365 7442 6B43 6F6C  ject....SetBkCol\n6F72 0000 3501 5365  7454 6578 7443 6F6C  or..5.SetTextCol\n6F72 0000 4501 5465  7874 4F75 7441 0000  or..E.TextOutA..",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938449,
        "id": "5514cf2c-3efb-41a8-8e76-2d868d9c9629",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938449,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "This particular section represents the beginning of the list of import module and function names. If you begin examining the right section part of the data, you should recognize the names of familiar Win32 API functions and the module names they are found in. Reading from the top down, you get "
            ],
            [
              "GetOpenFileNameA",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", followed by the module name COMDLG32.DLL. Shortly after that, you get "
            ],
            [
              "CreateFontIndirectA",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", followed by the module GDI32.DLL and then the functions "
            ],
            [
              "GetDeviceCaps",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "GetStockObject",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", "
            ],
            [
              "GetTextMetrics",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", and so forth. This pattern repeats throughout the .idata section. The first module name is COMDLG32.DLL and the second is GDI32.DLL. Notice that only one function is imported from the first module, while many functions are imported from the second module. In both cases, the function names and the module name to which they belong are ordered such that a function name appears first, followed by the module name and then by the rest of the function names, if any. The following function demonstrates how to retrieve the function names for a specific module:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "This particular section represents the beginning of the list of import module and function names. If you begin examining the right section part of the data, you should recognize the names of familiar Win32 API functions and the module names they are found in. Reading from the top down, you get "
          },
          {
            "Text": "GetOpenFileNameA",
            "AttrFlags": 1
          },
          {
            "Text": ", followed by the module name COMDLG32.DLL. Shortly after that, you get "
          },
          {
            "Text": "CreateFontIndirectA",
            "AttrFlags": 1
          },
          {
            "Text": ", followed by the module GDI32.DLL and then the functions "
          },
          {
            "Text": "GetDeviceCaps",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "GetStockObject",
            "AttrFlags": 1
          },
          {
            "Text": ", "
          },
          {
            "Text": "GetTextMetrics",
            "AttrFlags": 1
          },
          {
            "Text": ", and so forth. This pattern repeats throughout the .idata section. The first module name is COMDLG32.DLL and the second is GDI32.DLL. Notice that only one function is imported from the first module, while many functions are imported from the second module. In both cases, the function names and the module name to which they belong are ordered such that a function name appears first, followed by the module name and then by the rest of the function names, if any. The following function demonstrates how to retrieve the function names for a specific module:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938449,
        "id": "1a854632-e9bf-4017-b075-d17c835c4557",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938449,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int  WINAPI GetImportFunctionNamesByModule (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      *pszModule,\n    char      **pszFunctions)\n{\n    PIMAGE_IMPORT_MODULE_DIRECTORY  pid;\n    IMAGE_SECTION_HEADER     idsh;\n    DWORD                    dwBase;\n    int                      nCnt = 0, nSize = 0;\n    DWORD                    dwFunction;\n    char                     *psz;\n\n\n    /* Locate section header for \".idata\" section. */\n    if (!GetSectionHdrByName (lpFile, \u0026idsh, \".idata\"))\n        return 0;\n\n    pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)ImageDirectoryOffset\n             (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);\n\n    dwBase = ((DWORD)pid. idsh.VirtualAddress);\n\n    /* Find module's pid. */\n    while (pid-\u003edwRVAModuleName \u0026\u0026\n           strcmp (pszModule,\n                  (char *)(pid-\u003edwRVAModuleName+dwBase)))\n        pid++;\n\n    /* Exit if the module is not found. */\n    if (!pid-\u003edwRVAModuleName)\n        return 0;\n\n    /* Count number of function names and length of strings. */\n    dwFunction = pid-\u003edwRVAFunctionNameList;\n    while (dwFunction                      \u0026\u0026\n           *(DWORD *)(dwFunction + dwBase) \u0026\u0026\n           *(char *)((*(DWORD *)(dwFunction + dwBase)) +\n            dwBase+2))\n        {\n        nSize += strlen ((char *)((*(DWORD *)(dwFunction +\n             dwBase)) + dwBase+2)) + 1;\n        dwFunction += 4;\n        nCnt++;\n        }\n\n    /* Allocate memory off heap for function names. */\n    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize);\n    psz = *pszFunctions;\n\n    /* Copy function names to memory pointer. */\n    dwFunction = pid-\u003edwRVAFunctionNameList;\n    while (dwFunction                      \u0026\u0026\n           *(DWORD *)(dwFunction + dwBase) \u0026\u0026\n           *((char *)((*(DWORD *)(dwFunction + dwBase)) +\n            dwBase+2)))\n        {\n        strcpy (psz, (char *)((*(DWORD *)(dwFunction + dwBase)) +\n                dwBase+2));\n        psz += strlen((char *)((*(DWORD *)(dwFunction + dwBase))+\n                dwBase+2)) + 1;\n        dwFunction += 4;\n        }\n\n    return nCnt;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int  WINAPI GetImportFunctionNamesByModule (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      *pszModule,\n    char      **pszFunctions)\n{\n    PIMAGE_IMPORT_MODULE_DIRECTORY  pid;\n    IMAGE_SECTION_HEADER     idsh;\n    DWORD                    dwBase;\n    int                      nCnt = 0, nSize = 0;\n    DWORD                    dwFunction;\n    char                     *psz;\n\n\n    /* Locate section header for \".idata\" section. */\n    if (!GetSectionHdrByName (lpFile, \u0026idsh, \".idata\"))\n        return 0;\n\n    pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)ImageDirectoryOffset\n             (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);\n\n    dwBase = ((DWORD)pid. idsh.VirtualAddress);\n\n    /* Find module's pid. */\n    while (pid-\u003edwRVAModuleName \u0026\u0026\n           strcmp (pszModule,\n                  (char *)(pid-\u003edwRVAModuleName+dwBase)))\n        pid++;\n\n    /* Exit if the module is not found. */\n    if (!pid-\u003edwRVAModuleName)\n        return 0;\n\n    /* Count number of function names and length of strings. */\n    dwFunction = pid-\u003edwRVAFunctionNameList;\n    while (dwFunction                      \u0026\u0026\n           *(DWORD *)(dwFunction + dwBase) \u0026\u0026\n           *(char *)((*(DWORD *)(dwFunction + dwBase)) +\n            dwBase+2))\n        {\n        nSize += strlen ((char *)((*(DWORD *)(dwFunction +\n             dwBase)) + dwBase+2)) + 1;\n        dwFunction += 4;\n        nCnt++;\n        }\n\n    /* Allocate memory off heap for function names. */\n    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize);\n    psz = *pszFunctions;\n\n    /* Copy function names to memory pointer. */\n    dwFunction = pid-\u003edwRVAFunctionNameList;\n    while (dwFunction                      \u0026\u0026\n           *(DWORD *)(dwFunction + dwBase) \u0026\u0026\n           *((char *)((*(DWORD *)(dwFunction + dwBase)) +\n            dwBase+2)))\n        {\n        strcpy (psz, (char *)((*(DWORD *)(dwFunction + dwBase)) +\n                dwBase+2));\n        psz += strlen((char *)((*(DWORD *)(dwFunction + dwBase))+\n                dwBase+2)) + 1;\n        dwFunction += 4;\n        }\n\n    return nCnt;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938449,
        "id": "9f9b7a58-6d15-4d05-b8d1-5c8c2a822765",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938449,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Like the "
            ],
            [
              "GetImportModuleNames",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " function, this function relies on the end of each list of information to have a zeroed entry. In this case, the list of function names ends with one that is zero. The final field, "
            ],
            [
              "dwRVAFunctionAddressList",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", is a relative virtual address to a list of virtual addresses that will be placed in the section data by the loader when the file is loaded. Before the file is loaded, however, these virtual addresses are replaced by relative virtual addresses that correspond exactly to the list of function names. So before the file is loaded, there are two identical lists of relative virtual addresses pointing to imported function names."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Like the "
          },
          {
            "Text": "GetImportModuleNames",
            "AttrFlags": 1
          },
          {
            "Text": " function, this function relies on the end of each list of information to have a zeroed entry. In this case, the list of function names ends with one that is zero. The final field, "
          },
          {
            "Text": "dwRVAFunctionAddressList",
            "AttrFlags": 4
          },
          {
            "Text": ", is a relative virtual address to a list of virtual addresses that will be placed in the section data by the loader when the file is loaded. Before the file is loaded, however, these virtual addresses are replaced by relative virtual addresses that correspond exactly to the list of function names. So before the file is loaded, there are two identical lists of relative virtual addresses pointing to imported function names."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938449,
        "id": "ebcd215b-2d00-4487-b124-17add1e085b9",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938449,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Debug information section, .debug"
            ]
          ]
        },
        "type": "sub_header",
        "version": 1,
        "inline_content": [
          {
            "Text": "Debug information section, .debug"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938449,
        "id": "766d4fcf-3481-476e-9f11-981365cbc282",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938449,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "Debug information is initially placed in the .debug section. The PE file format also supports separate debug files (normally identified with a .DBG extension) as a means of collecting debug information in a central location. The debug section contains the debug information, but the debug directories live in the .rdata section mentioned earlier. Each of those directories references debug information in the .debug section. The debug directory structure is defined as an "
            ],
            [
              "IMAGE_DEBUG_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              ", as follows: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "Debug information is initially placed in the .debug section. The PE file format also supports separate debug files (normally identified with a .DBG extension) as a means of collecting debug information in a central location. The debug section contains the debug information, but the debug directories live in the .rdata section mentioned earlier. Each of those directories references debug information in the .debug section. The debug directory structure is defined as an "
          },
          {
            "Text": "IMAGE_DEBUG_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": ", as follows: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938450,
        "id": "eb426ca0-e7a8-457c-b655-6dc9bdda64e1",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938450,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "typedef struct _IMAGE_DEBUG_DIRECTORY {\n    ULONG   Characteristics;\n    ULONG   TimeDateStamp;\n    USHORT  MajorVersion;\n    USHORT  MinorVersion;\n    ULONG   Type;\n    ULONG   SizeOfData;\n    ULONG   AddressOfRawData;\n    ULONG   PointerToRawData;\n} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "typedef struct _IMAGE_DEBUG_DIRECTORY {\n    ULONG   Characteristics;\n    ULONG   TimeDateStamp;\n    USHORT  MajorVersion;\n    USHORT  MinorVersion;\n    ULONG   Type;\n    ULONG   SizeOfData;\n    ULONG   AddressOfRawData;\n    ULONG   PointerToRawData;\n} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938450,
        "id": "f7be3258-0896-4962-b936-8bd65e1ae044",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938450,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The section is divided into separate portions of data representing different types of debug information. For each one there is a debug directory described above. The different types of debug information are listed below: "
            ],
            [
              "WINNT.H",
              [
                [
                  "b"
                ]
              ]
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The section is divided into separate portions of data representing different types of debug information. For each one there is a debug directory described above. The different types of debug information are listed below: "
          },
          {
            "Text": "WINNT.H",
            "AttrFlags": 1
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938450,
        "id": "c84e3f15-9a6b-495c-ba1d-2c4e1038ac86",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938450,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "#define IMAGE_DEBUG_TYPE_UNKNOWN          0\n#define IMAGE_DEBUG_TYPE_COFF             1\n#define IMAGE_DEBUG_TYPE_CODEVIEW         2\n#define IMAGE_DEBUG_TYPE_FPO              3\n#define IMAGE_DEBUG_TYPE_MISC             4"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "#define IMAGE_DEBUG_TYPE_UNKNOWN          0\n#define IMAGE_DEBUG_TYPE_COFF             1\n#define IMAGE_DEBUG_TYPE_CODEVIEW         2\n#define IMAGE_DEBUG_TYPE_FPO              3\n#define IMAGE_DEBUG_TYPE_MISC             4",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938450,
        "id": "9c55466e-2488-425a-8233-c28e5c3ceda5",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938450,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The "
            ],
            [
              "Type",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              " field in each directory indicates which type of debug information the directory represents. As you can see in the list above, the PE file format supports many different types of debug information, as well as some other informational fields. Of those, the "
            ],
            [
              "IMAGE_DEBUG_TYPE_MISC",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " information is unique. This information was added to represent miscellaneous information about the executable image that could not be added to any of the more structured data sections in the PE file format. This is the only location in the image file where the image name is sure to appear. If an image exports information, the export data section will also include the image name. Each type of debug information has its own header structure that defines its data. Each of these is listed in the file WINNT.H. One nice thing about the "
            ],
            [
              "IMAGE_DEBUG_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure is that it includes two fields that identify the debug information. The first of these, "
            ],
            [
              "AddressOfRawData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", is the relative virtual address of the data once the file is loaded. The other, "
            ],
            [
              "PointerToRawData",
              [
                [
                  "i"
                ]
              ]
            ],
            [
              ", is an actual offset within the PE file, where the data is located. This makes it easy to locate specific debug information. As a last example, consider the following function, which extracts the image name from the "
            ],
            [
              "IMAGE_DEBUG_MISC",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The "
          },
          {
            "Text": "Type",
            "AttrFlags": 4
          },
          {
            "Text": " field in each directory indicates which type of debug information the directory represents. As you can see in the list above, the PE file format supports many different types of debug information, as well as some other informational fields. Of those, the "
          },
          {
            "Text": "IMAGE_DEBUG_TYPE_MISC",
            "AttrFlags": 1
          },
          {
            "Text": " information is unique. This information was added to represent miscellaneous information about the executable image that could not be added to any of the more structured data sections in the PE file format. This is the only location in the image file where the image name is sure to appear. If an image exports information, the export data section will also include the image name. Each type of debug information has its own header structure that defines its data. Each of these is listed in the file WINNT.H. One nice thing about the "
          },
          {
            "Text": "IMAGE_DEBUG_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": " structure is that it includes two fields that identify the debug information. The first of these, "
          },
          {
            "Text": "AddressOfRawData",
            "AttrFlags": 4
          },
          {
            "Text": ", is the relative virtual address of the data once the file is loaded. The other, "
          },
          {
            "Text": "PointerToRawData",
            "AttrFlags": 4
          },
          {
            "Text": ", is an actual offset within the PE file, where the data is located. This makes it easy to locate specific debug information. As a last example, consider the following function, which extracts the image name from the "
          },
          {
            "Text": "IMAGE_DEBUG_MISC",
            "AttrFlags": 1
          },
          {
            "Text": " structure:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938450,
        "id": "b8a34aa7-789e-461c-93f2-f7e789706a9d",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938450,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "int    WINAPI RetrieveModuleName (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszModule)\n{\n\n    PIMAGE_DEBUG_DIRECTORY    pdd;\n    PIMAGE_DEBUG_MISC         pdm = NULL;\n    int                       nCnt;\n\n    if (!(pdd = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryOffset\n               (lpFile, IMAGE_DIRECTORY_ENTRY_DEBUG)))\n        return 0;\n\n    while (pdd-\u003eSizeOfData)\n        {\n        if (pdd-\u003eType == IMAGE_DEBUG_TYPE_MISC)\n            {\n            pdm = (PIMAGE_DEBUG_MISC)\n                ((DWORD)pdd-\u003ePointerToRawData + (DWORD)lpFile);\n\n            nCnt = lstrlen (pdm-\u003eData)*(pdm-\u003eUnicode?2:1);\n            *pszModule = (char *)HeapAlloc (hHeap,\n                                            HEAP_ZERO_MEMORY,\n                                            nCnt+1;\n            CopyMemory (*pszModule, pdm-\u003eData, nCnt);\n\n            break;\n            }\n\n        pdd ++;\n        }\n\n    if (pdm != NULL)\n        return nCnt;\n    else\n        return 0;\n}"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "int    WINAPI RetrieveModuleName (\n    LPVOID    lpFile,\n    HANDLE    hHeap,\n    char      **pszModule)\n{\n\n    PIMAGE_DEBUG_DIRECTORY    pdd;\n    PIMAGE_DEBUG_MISC         pdm = NULL;\n    int                       nCnt;\n\n    if (!(pdd = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryOffset\n               (lpFile, IMAGE_DIRECTORY_ENTRY_DEBUG)))\n        return 0;\n\n    while (pdd-\u003eSizeOfData)\n        {\n        if (pdd-\u003eType == IMAGE_DEBUG_TYPE_MISC)\n            {\n            pdm = (PIMAGE_DEBUG_MISC)\n                ((DWORD)pdd-\u003ePointerToRawData + (DWORD)lpFile);\n\n            nCnt = lstrlen (pdm-\u003eData)*(pdm-\u003eUnicode?2:1);\n            *pszModule = (char *)HeapAlloc (hHeap,\n                                            HEAP_ZERO_MEMORY,\n                                            nCnt+1;\n            CopyMemory (*pszModule, pdm-\u003eData, nCnt);\n\n            break;\n            }\n\n        pdd ++;\n        }\n\n    if (pdm != NULL)\n        return nCnt;\n    else\n        return 0;\n}",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938451,
        "id": "670db396-dacf-4493-83de-7ef2b9272272",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938451,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "As you can see, the structure of the debug directory makes it relatively easy to locate a specific type of debug information. Once the "
            ],
            [
              "IMAGE_DEBUG_MISC",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure is located, extracting the image name is as simple as invoking the "
            ],
            [
              "CopyMemory",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " function. As mentioned above, debug information can be stripped into separate .DBG files. The Windows NT SDK includes a utility called REBASE.EXE that serves this purpose. For example, in the following statement an executable image named TEST.EXE is being stripped of debug information:"
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "As you can see, the structure of the debug directory makes it relatively easy to locate a specific type of debug information. Once the "
          },
          {
            "Text": "IMAGE_DEBUG_MISC",
            "AttrFlags": 1
          },
          {
            "Text": " structure is located, extracting the image name is as simple as invoking the "
          },
          {
            "Text": "CopyMemory",
            "AttrFlags": 1
          },
          {
            "Text": " function. As mentioned above, debug information can be stripped into separate .DBG files. The Windows NT SDK includes a utility called REBASE.EXE that serves this purpose. For example, in the following statement an executable image named TEST.EXE is being stripped of debug information:"
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938451,
        "id": "1e9591ce-c73e-4d05-83f6-d240b8e6bcae",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938451,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "language": [
            [
              "Plain Text"
            ]
          ],
          "title": [
            [
              "rebase -b 40000 -x c:\\samples\\testdir test.exe"
            ]
          ]
        },
        "type": "code",
        "version": 1,
        "code": "rebase -b 40000 -x c:\\samples\\testdir test.exe",
        "code_language": "Plain Text"
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938451,
        "id": "ca8945e4-2a43-4a48-845a-e6331bbc530a",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072938451,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "properties": {
          "title": [
            [
              "The debug information is placed in a new file called TEST.DBG and located in the path specified, in this case c:. The file begins with a single "
            ],
            [
              "IMAGE_SEPARATE_DEBUG_HEADER",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structure, followed by a copy of the section headers that exist in the stripped executable image. Then the .debug section data follows the section headers. So, right after the section headers are the series of "
            ],
            [
              "IMAGE_DEBUG_DIRECTORY",
              [
                [
                  "b"
                ]
              ]
            ],
            [
              " structures and their associated data. The debug information itself retains the same structure as described above for normal image file debug information."
            ]
          ]
        },
        "type": "text",
        "version": 1,
        "inline_content": [
          {
            "Text": "The debug information is placed in a new file called TEST.DBG and located in the path specified, in this case c:. The file begins with a single "
          },
          {
            "Text": "IMAGE_SEPARATE_DEBUG_HEADER",
            "AttrFlags": 1
          },
          {
            "Text": " structure, followed by a copy of the section headers that exist in the stripped executable image. Then the .debug section data follows the section headers. So, right after the section headers are the series of "
          },
          {
            "Text": "IMAGE_DEBUG_DIRECTORY",
            "AttrFlags": 1
          },
          {
            "Text": " structures and their associated data. The debug information itself retains the same structure as described above for normal image file debug information."
          }
        ]
      },
      {
        "alive": true,
        "created_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "created_time": 1530072938451,
        "id": "23882655-d9fe-43be-b2a6-c3859a840533",
        "ignore_block_count": true,
        "last_edited_by": "bb760e2d-d679-4b64-b2a9-03005b21870a",
        "last_edited_time": 1530072972813,
        "parent_id": "0fca179d-ac6b-4c28-8cff-794d2fc2d781",
        "parent_table": "block",
        "type": "text",
        "version": 11
      }
    ],
    "title": "PE file format description",
    "format_page": {
      "page_cover": "",
      "page_cover_position": 0,
      "page_font": "",
      "page_full_width": true,
      "page_icon": "",
      "page_small_text": true
    }
  },
  "Users": [
    {
      "email": "kkowalczyk@gmail.com",
      "family_name": "Kowalczyk",
      "given_name": "Krzysztof",
      "id": "bb760e2d-d679-4b64-b2a9-03005b21870a",
      "locale": "en",
      "mobile_onboarding_completed": true,
      "onboarding_completed": true,
      "profile_photo": "https://s3-us-west-2.amazonaws.com/public.notion-static.com/2dcaa66c-7674-4ff6-9924-601785b63561/head-bw-640x960.png",
      "time_zone": "America/Los_Angeles",
      "version": 10
    }
  ],
  "Collections": null,
  "CollectionViews": null
}